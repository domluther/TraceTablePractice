<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trace Table Practice - Unit Tests</title>
    <link rel="stylesheet" href="css/test-styles.css">
</head>
<body>
    <div class="container">
        <h1>üß™ Trace Table Practice - Unit Tests</h1>
        
        <div id="testSummary"></div>
        
        <button class="run-tests-btn" onclick="runAllTests()">üîÑ Run All Tests</button>
        <button class="toggle-btn" id="togglePassedBtn" onclick="togglePassedTests()" title="Toggle passed tests visibility (Shortcut: H key)">üëÅÔ∏è Show Passed Tests</button>
        
        <div id="testResults"></div>
    </div>

    <script type="module">
        // ============================================================================
        // UNIT TESTS - SCOPE AND PURPOSE
        // ============================================================================
        /*
         * These unit tests focus on testing individual interpreter methods and
         * language features in isolation. They verify that each component works
         * correctly on its own, without testing complete program flows.
         * 
         * UNIT TEST SCOPE:
         * - Individual arithmetic operations and operator precedence
         * - String methods (.upper, .lower, .left, .substring, etc.)
         * - Array access and indexing
         * - Type conversions (float, int, bool)
         * - Basic control structures (for loops, switch/case)
         * - Language features (comments, constants)
         * - Edge cases and error conditions
         * - Expression evaluation and parsing
         * 
         * DESIGN PRINCIPLES:
         * - Each test function focuses on one specific feature or capability
         * - Tests are independent and can run in any order
         * - Clear naming conventions make test purpose obvious
         * - Comprehensive coverage without redundancy
         * - Maintainable structure with clear section organization
         * 
         * For comprehensive program testing, see integration-tests.html
         */
        
        // ============================================================================
        // TEST FRAMEWORK AND UTILITIES
        // ============================================================================
        
        // Import the actual production Interpreter class
        import { Interpreter } from './js/interpreter.js';
        
        // Test state management
        let testResults = [];
        let testsPassed = 0;
        let testsFailed = 0;
        
        /**
         * Core assertion function for unit testing
         * @param {boolean} condition - The condition to test
         * @param {string} testName - Descriptive name of the test
         * @param {string} details - Additional diagnostic information
         */
        function assert(condition, testName, details = '') {
            if (condition) {
                testResults.push({
                    name: testName,
                    passed: true,
                    details: details
                });
                testsPassed++;
            } else {
                testResults.push({
                    name: testName,
                    passed: false,
                    details: details
                });
                testsFailed++;
            }
        }
        
        /**
         * Equality assertion with detailed failure reporting
         * @param {any} actual - The actual value produced
         * @param {any} expected - The expected value
         * @param {string} testName - Descriptive name of the test
         * @param {string} details - Additional context
         */
        function assertEqual(actual, expected, testName, details = '') {
            const condition = actual === expected;
            const testDetails = details + ` (Expected: ${expected}, Got: ${actual})`;
            assert(condition, testName, testDetails);
        }
        
        /**
         * Array equality assertion for comprehensive comparisons
         * @param {Array} actual - The actual array produced
         * @param {Array} expected - The expected array
         * @param {string} testName - Descriptive name of the test
         * @param {string} details - Additional context
         */
        function assertArrayEqual(actual, expected, testName, details = '') {
            const condition = JSON.stringify(actual) === JSON.stringify(expected);
            const testDetails = details + ` (Expected: ${JSON.stringify(expected)}, Got: ${JSON.stringify(actual)})`;
            assert(condition, testName, testDetails);
        }
        
        // ============================================================================
        // BASIC ARITHMETIC OPERATIONS TESTS
        // ============================================================================
        
        /**
         * Test basic arithmetic operations
         * Covers: addition, subtraction, multiplication, division, modulo, exponentiation
         */
        function testBasicArithmetic() {
            const interpreter = new Interpreter();
            const vars = { a: 5, b: 3, c: 2 };
            
            // Test basic operations
            assertEqual(interpreter.evaluateArithmeticExpression('a + b', vars), 8, 'Basic Addition (5 + 3 = 8)');
            assertEqual(interpreter.evaluateArithmeticExpression('a - b', vars), 2, 'Basic Subtraction (5 - 3 = 2)');
            assertEqual(interpreter.evaluateArithmeticExpression('a * b', vars), 15, 'Basic Multiplication (5 * 3 = 15)');
            assertEqual(interpreter.evaluateArithmeticExpression('a / c', vars), 2.5, 'Basic Division (5 / 2 = 2.5)');
            assertEqual(interpreter.evaluateArithmeticExpression('a MOD b', vars), 2, 'Basic Modulo (5 MOD 3 = 2)');
            assertEqual(interpreter.evaluateArithmeticExpression('b ^ c', vars), 9, 'Basic Exponentiation (3 ^ 2 = 9)');
        }
        
        /**
         * Test operator precedence rules
         * Covers: order of operations, left-to-right evaluation
         */
        function testOperatorPrecedence() {
            const interpreter = new Interpreter();
            const vars = { a: 2, b: 3, c: 4 };
            
            // Test precedence rules
            assertEqual(interpreter.evaluateArithmeticExpression('a + b * c', vars), 14, 'Multiplication before Addition (2 + 3 * 4 = 14)');
            assertEqual(interpreter.evaluateArithmeticExpression('c / a - b', vars), -1, 'Division before Subtraction (4 / 2 - 3 = -1)');
            assertEqual(interpreter.evaluateArithmeticExpression('a * b ^ a', vars), 18, 'Exponentiation before Multiplication (2 * 3 ^ 2 = 18)');
            assertEqual(interpreter.evaluateArithmeticExpression('a + b - c', vars), 1, 'Left-to-right for Addition/Subtraction (2 + 3 - 4 = 1)');
            assertEqual(interpreter.evaluateArithmeticExpression('a * b / a', vars), 3, 'Left-to-right for Multiplication/Division (2 * 3 / 2 = 3)');
        }
        
        /**
         * Test parentheses in expressions
         * Covers: grouping, nested parentheses, complex expressions
         */
        function testParentheses() {
            const interpreter = new Interpreter();
            const vars = { a: 2, b: 3, c: 4 };
            
            // Test parentheses
            assertEqual(interpreter.evaluateArithmeticExpression('(a + b) * c', vars), 20, 'Basic Parentheses ((2 + 3) * 4 = 20)');
            assertEqual(interpreter.evaluateArithmeticExpression('((a + b) * c) / (a + c)', vars), 20/6, 'Nested Parentheses (((2 + 3) * 4) / (2 + 4) = 20/6)');
            
            // Rectangle perimeter calculation
            const rectVars = { length: 5, width: 3 };
            assertEqual(interpreter.evaluateArithmeticExpression('2 * (length + width)', rectVars), 16, 'Rectangle Perimeter (2 * (5 + 3) = 16)');
            assertEqual(interpreter.evaluateArithmeticExpression('(a + b) * (c - a)', vars), 10, 'Complex Parentheses ((2 + 3) * (4 - 2) = 10)');
        }
        
        /**
         * Test array access operations
         * Covers: variable indices, literal indices, arithmetic with arrays
         */
        function testArrayAccess() {
            const interpreter = new Interpreter();
            const vars = { 
                nums: [10, 20, 30], 
                i: 1,
                j: 0
            };
            
            // Test array access
            assertEqual(interpreter.getExpressionValue('nums[i]', vars), 20, 'Array Access with Variable Index (nums[1] = 20)');
            assertEqual(interpreter.getExpressionValue('nums[0]', vars), 10, 'Array Access with Literal Index (nums[0] = 10)');
            assertEqual(interpreter.evaluateArithmeticExpression('nums[i] + nums[j]', vars), 30, 'Arithmetic with Array Access (nums[1] + nums[0] = 30)');
            assertEqual(interpreter.evaluateArithmeticExpression('nums[i] * 2', vars), 40, 'Array Access in Multiplication (nums[1] * 2 = 40)');
        }
        
        /**
         * Test string method operations
         * Covers: .upper, .lower, .left, string concatenation
         */
        function testStringMethods() {
            const interpreter = new Interpreter();
            const vars = {
                first_name: 'John',
                last_name: 'Smith',
                count: 4
            };
            
            // Test string methods
            const firstInitial = interpreter.evaluateStringConcatenation('first_name.left(1)', vars);
            assertEqual(firstInitial, 'J', 'First name .left(1) should return "J"');
            
            const lastInitial = interpreter.evaluateStringConcatenation('last_name.left(1)', vars);
            assertEqual(lastInitial, 'S', 'Last name .left(1) should return "S"');
            
            const initials = interpreter.evaluateStringConcatenation('first_name.left(1) + last_name.left(1)', vars);
            assertEqual(initials, 'JS', 'Initials concatenation should return "JS"');
            
            assertEqual(interpreter.evaluateStringConcatenation('first_name.upper', vars), 'JOHN', 'String .upper method');
            assertEqual(interpreter.evaluateStringConcatenation('first_name.lower', vars), 'john', 'String .lower method');
        }
        
        /**
         * Test DIV and MOD operations (duck grouping)
         * Covers: integer division and remainder operations
         */
        function testDuckGrouping() {
            const interpreter = new Interpreter();
            
            // Test duck grouping scenarios
            assertEqual(interpreter.evaluateArithmeticExpression('15 DIV 4', {}), 3, 'Duck Grouping DIV (15 DIV 4 = 3)');
            assertEqual(interpreter.evaluateArithmeticExpression('15 MOD 4', {}), 3, 'Duck Grouping MOD (15 MOD 4 = 3)');
            assertEqual(interpreter.evaluateArithmeticExpression('22 DIV 4', {}), 5, 'Duck Grouping DIV (22 DIV 4 = 5)');
            assertEqual(interpreter.evaluateArithmeticExpression('22 MOD 4', {}), 2, 'Duck Grouping MOD (22 MOD 4 = 2)');
        }
        
        /**
         * Test for loop execution
         * Covers: loop variables, trace entries, output generation
         */
        function testForLoopExecution() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: [], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                for x = 0 to 2
                    print(x*2)
                next x
            `, testProgram);
            
            // Check variables and outputs
            assertEqual(testInterpreter.variables.x, 2, 'x should be 2 after loop completion');
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], '0', 'First output should be "0"');
            assertEqual(testInterpreter.outputs[1], '2', 'Second output should be "2"');
            assertEqual(testInterpreter.outputs[2], '4', 'Third output should be "4"');
        }
        
        /**
         * Test variable operations and expressions
         * Covers: variable access, numeric literals, expression evaluation
         */
        function testVariableOperations() {
            const interpreter = new Interpreter();
            const vars = { 
                x: 10, 
                y: 0,
                temp: 5
            };
            
            // Test variable access
            assertEqual(interpreter.getExpressionValue('x', vars), 10, 'Variable Access (x = 10)');
            assertEqual(interpreter.getExpressionValue('temp', vars), 5, 'Variable Access (temp = 5)');
            
            // Test numeric literals
            assertEqual(interpreter.getExpressionValue('42', vars), 42, 'Numeric Literal (42)');
            assertEqual(interpreter.getExpressionValue('0', vars), 0, 'Numeric Literal (0)');
        }
        
        /**
         * Test complex expressions
         * Covers: multi-operator expressions, nested operations
         */
        function testComplexExpressions() {
            const interpreter = new Interpreter();
            const vars = { 
                a: 2, 
                b: 3, 
                c: 4,
                nums: [1, 2, 3, 4, 5],
                index: 2
            };
            
            // Test complex arithmetic expression
            assertEqual(interpreter.evaluateArithmeticExpression('a * b + c * (a + b) - nums[index]', vars), 23, 
                'Complex Expression (2 * 3 + 4 * (2 + 3) - 3 = 23)');
            
            // Test expression with multiple operators
            assertEqual(interpreter.evaluateArithmeticExpression('a ^ b + c / a * nums[0]', vars), 10, 
                'Multiple Operators (2 ^ 3 + 4 / 2 * 1 = 10)');
        }
        
        /**
         * Test edge cases and boundary conditions
         * Covers: division by one, multiplication by zero, array bounds
         */
        function testEdgeCases() {
            const interpreter = new Interpreter();
            const vars = { 
                zero: 0, 
                one: 1, 
                ten: 10,
                emptyArray: [],
                smallArray: [42]
            };
            
            // Test edge operations
            assertEqual(interpreter.evaluateArithmeticExpression('ten / one', vars), 10, 'Division by One (10 / 1 = 10)');
            assertEqual(interpreter.evaluateArithmeticExpression('ten * zero', vars), 0, 'Multiplication by Zero (10 * 0 = 0)');
            assertEqual(interpreter.evaluateArithmeticExpression('ten ^ zero', vars), 1, 'Power of Zero (10 ^ 0 = 1)');
            
            // Test array bounds (should return 0 for out of bounds)
            assertEqual(interpreter.getExpressionValue('emptyArray[0]', vars), 0, 'Empty Array Access (should return 0)');
            assertEqual(interpreter.getExpressionValue('smallArray[5]', vars), 0, 'Out of Bounds Array Access (should return 0)');
        }
        
        /**
         * Test type conversions
         * Covers: float(), int(), bool() type casting
         */
        function testTypeConversions() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: ["3.14", "2.5"], randomValue: undefined };
            
            // Test float conversion
            const result = testInterpreter.executeProgram(`
                x = float(input("Enter number"))
                print(x)
            `, testProgram);
            
            assertEqual(testInterpreter.variables.x, 3.14, 'float(input()) should convert "3.14" to 3.14');
        }
        
        /**
         * Test nested conditional execution
         * Covers: if/then/else logic, nested conditions
         */
        function testNestedConditionalExecution() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: ["2.5", "8"], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                jumpLength = float(input("Enter jump length"))
                yearGroup = float(input("Enter year group"))
                if jumpLength > 2 then
                    if yearGroup >= 10 then
                        result = "qualify"
                    else
                        result = "too young"
                    endif
                else
                    result = "not long enough"
                endif
            `, testProgram);
            
            assertEqual(testInterpreter.variables.jumpLength, 2.5, 'jumpLength should be 2.5');
            assertEqual(testInterpreter.variables.yearGroup, 8, 'yearGroup should be 8');
            assertEqual(testInterpreter.variables.result, "too young", 'Should execute inner else branch');
        }
        
        /**
         * Test string methods in print statements
         * Covers: string methods used directly in output
         */
        function testStringMethodsInPrint() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: ["hello", "WORLD"], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                name = input("Enter name")
                city = input("Enter city")
                print(name.upper)
                print(city.lower)
                print(name.length)
            `, testProgram);
            
            // Check variables and outputs
            assertEqual(testInterpreter.variables.name, 'hello', 'name should be "hello"');
            assertEqual(testInterpreter.variables.city, 'WORLD', 'city should be "WORLD"');
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], 'HELLO', 'First output should be "HELLO"');
            assertEqual(testInterpreter.outputs[1], 'world', 'Second output should be "world"');
            assertEqual(testInterpreter.outputs[2], '5', 'Third output should be "5"');
        }
        
        /**
         * Test substring with variable parameters
         * Covers: substring method with dynamic parameters
         */
        function testSubstringWithVariable() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: [], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                for x = 1 to 3
                    country = "France"
                    print(country.substring(x, 1))
                next x
            `, testProgram);
            
            // Check outputs - should extract characters at positions 1, 2, 3 (r, a, n)
            assertEqual(testInterpreter.variables.x, 3, 'x should be 3 after loop completion');
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], 'r', 'First output should be "r" (position 1)');
            assertEqual(testInterpreter.outputs[1], 'a', 'Second output should be "a" (position 2)');
            assertEqual(testInterpreter.outputs[2], 'n', 'Third output should be "n" (position 3)');
        }
        
        /**
         * Test comment handling
         * Covers: comments ignored in execution, proper line tracing
         */
        function testComments() {
            const testInterpreter = new Interpreter();
            
            const codeWithComments = `// This is a comment
x = 5
// Another comment here
y = 10
// Final comment
z = x + y`;
            
            const result = testInterpreter.execute(codeWithComments);
            
            // Verify that only assignment lines are traced, comments are ignored
            assertEqual(testInterpreter.variables.x, 5, 'x should be 5 despite comments');
            assertEqual(testInterpreter.variables.y, 10, 'y should be 10 despite comments');
            assertEqual(testInterpreter.variables.z, 15, 'z should be 15 (x + y)');
            assertEqual(testInterpreter.trace.length, 3, 'Should have exactly 3 trace entries (no comments traced)');
        }
        
        /**
         * Test boolean casting
         * Covers: bool() function with different input types
         */
        function testBoolCasting() {
            const testInterpreter = new Interpreter();
            
            const boolTestCode = `isTrue = bool("True")
isFalse = bool("False")
isZero = bool(0)
isOne = bool(1)`;
            
            const result = testInterpreter.execute(boolTestCode);
            
            assertEqual(testInterpreter.variables.isTrue, true, 'bool("True") should be true');
            assertEqual(testInterpreter.variables.isFalse, false, 'bool("False") should be false');
            assertEqual(testInterpreter.variables.isZero, false, 'bool(0) should be false');
            assertEqual(testInterpreter.variables.isOne, true, 'bool(1) should be true');
        }
        
        /**
         * Test constant declarations
         * Covers: const keyword, constant protection
         */
        function testConstants() {
            const testInterpreter = new Interpreter();
            
            const constCode = `const pi = 3.14159
const vat = 0.2
price = 100
total = price * (1 + vat)`;
            
            const result = testInterpreter.execute(constCode);
            
            assertEqual(testInterpreter.variables.pi, 3.14159, 'const pi should be 3.14159');
            assertEqual(testInterpreter.variables.vat, 0.2, 'const vat should be 0.2');
            assertEqual(testInterpreter.variables.total, 120, 'total should be 120 (100 * 1.2)');
        }
        
        /**
         * Test for loops with positive step
         * Covers: step parameter, range iteration
         */
        function testForLoopWithPositiveStep() {
            const testInterpreter = new Interpreter();
            
            const positiveStepCode = `for i = 2 to 10 step 2
    print(i)
next i`;
            
            const result = testInterpreter.execute(positiveStepCode);
            
            // Should print even numbers: 2, 4, 6, 8, 10
            assertEqual(testInterpreter.outputs.length, 5, 'Should have 5 outputs for step 2');
            assertEqual(testInterpreter.outputs[0], '2', 'First output should be "2"');
            assertEqual(testInterpreter.outputs[1], '4', 'Second output should be "4"');
            assertEqual(testInterpreter.outputs[4], '10', 'Fifth output should be "10"');
        }
        
        /**
         * Test for loops with negative step
         * Covers: countdown loops, negative step values
         */
        function testForLoopWithNegativeStep() {
            const testInterpreter = new Interpreter();
            
            const negativeStepCode = `for i = 10 to 0 step -1
    print(i)
next i`;
            
            const result = testInterpreter.execute(negativeStepCode);
            
            // Should print countdown: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
            assertEqual(testInterpreter.outputs.length, 11, 'Should have 11 outputs for countdown');
            assertEqual(testInterpreter.outputs[0], '10', 'First output should be "10"');
            assertEqual(testInterpreter.outputs[10], '0', 'Eleventh output should be "0"');
        }
        
        /**
         * Test switch/case statements
         * Covers: switch logic, case matching, default cases
         */
        function testSwitchCase() {
            const testInterpreter = new Interpreter();
            
            const basicSwitchCode = `day = "Mon"
switch day:
case "Mon":
    print("Monday")
case "Tue":
    print("Tuesday")
default:
    print("Unknown day")
endswitch
print("Done")`;
            
            const result = testInterpreter.execute(basicSwitchCode);
            
            assertEqual(testInterpreter.variables.day, 'Mon', 'day should be "Mon"');
            assertEqual(testInterpreter.outputs.length, 2, 'Should have exactly 2 outputs');
            assertEqual(testInterpreter.outputs[0], 'Monday', 'First output should be "Monday"');
            assertEqual(testInterpreter.outputs[1], 'Done', 'Second output should be "Done"');
        }
        
        // ============================================================================
        // BASIC ARITHMETIC OPERATIONS TESTS
        // ============================================================================
        
        /**
         * Test basic arithmetic operations
         * Covers: addition, subtraction, multiplication, division, modulo, exponentiation
         */
        function testBasicArithmetic() {
            const interpreter = new Interpreter();
            const vars = { a: 5, b: 3, c: 2 };
            
            // Test basic operations
            assertEqual(interpreter.evaluateArithmeticExpression('a + b', vars), 8, 'Basic Addition (5 + 3 = 8)');
            assertEqual(interpreter.evaluateArithmeticExpression('a - b', vars), 2, 'Basic Subtraction (5 - 3 = 2)');
            assertEqual(interpreter.evaluateArithmeticExpression('a * b', vars), 15, 'Basic Multiplication (5 * 3 = 15)');
            assertEqual(interpreter.evaluateArithmeticExpression('a / c', vars), 2.5, 'Basic Division (5 / 2 = 2.5)');
            assertEqual(interpreter.evaluateArithmeticExpression('a MOD b', vars), 2, 'Basic Modulo (5 MOD 3 = 2)');
            assertEqual(interpreter.evaluateArithmeticExpression('b ^ c', vars), 9, 'Basic Exponentiation (3 ^ 2 = 9)');
        }
        
        /**
         * Test operator precedence rules
         * Covers: order of operations, left-to-right evaluation
         */
        function testOperatorPrecedence() {
            const interpreter = new Interpreter();
            const vars = { a: 2, b: 3, c: 4 };
            
            // Test precedence rules
            assertEqual(interpreter.evaluateArithmeticExpression('a + b * c', vars), 14, 'Multiplication before Addition (2 + 3 * 4 = 14)');
            assertEqual(interpreter.evaluateArithmeticExpression('c / a - b', vars), -1, 'Division before Subtraction (4 / 2 - 3 = -1)');
            assertEqual(interpreter.evaluateArithmeticExpression('a * b ^ a', vars), 18, 'Exponentiation before Multiplication (2 * 3 ^ 2 = 18)');
            assertEqual(interpreter.evaluateArithmeticExpression('a + b - c', vars), 1, 'Left-to-right for Addition/Subtraction (2 + 3 - 4 = 1)');
            assertEqual(interpreter.evaluateArithmeticExpression('a * b / a', vars), 3, 'Left-to-right for Multiplication/Division (2 * 3 / 2 = 3)');
        }
        
        /**
         * Test parentheses in expressions
         * Covers: grouping, nested parentheses, complex expressions
         */
        function testParentheses() {
            const interpreter = new Interpreter();
            const vars = { a: 2, b: 3, c: 4 };
            
            // Test parentheses
            assertEqual(interpreter.evaluateArithmeticExpression('(a + b) * c', vars), 20, 'Basic Parentheses ((2 + 3) * 4 = 20)');
            assertEqual(interpreter.evaluateArithmeticExpression('((a + b) * c) / (a + c)', vars), 20/6, 'Nested Parentheses (((2 + 3) * 4) / (2 + 4) = 20/6)');
            
            // Rectangle perimeter calculation
            const rectVars = { length: 5, width: 3 };
            assertEqual(interpreter.evaluateArithmeticExpression('2 * (length + width)', rectVars), 16, 'Rectangle Perimeter (2 * (5 + 3) = 16)');
            assertEqual(interpreter.evaluateArithmeticExpression('(a + b) * (c - a)', vars), 10, 'Complex Parentheses ((2 + 3) * (4 - 2) = 10)');
        }
        
        /**
         * Test array access operations
         * Covers: variable indices, literal indices, arithmetic with arrays
         */
        function testArrayAccess() {
            const interpreter = new Interpreter();
            const vars = { 
                nums: [10, 20, 30], 
                i: 1,
                j: 0
            };
            
            // Test array access
            assertEqual(interpreter.getExpressionValue('nums[i]', vars), 20, 'Array Access with Variable Index (nums[1] = 20)');
            assertEqual(interpreter.getExpressionValue('nums[0]', vars), 10, 'Array Access with Literal Index (nums[0] = 10)');
            assertEqual(interpreter.evaluateArithmeticExpression('nums[i] + nums[j]', vars), 30, 'Arithmetic with Array Access (nums[1] + nums[0] = 30)');
            assertEqual(interpreter.evaluateArithmeticExpression('nums[i] * 2', vars), 40, 'Array Access in Multiplication (nums[1] * 2 = 40)');
        }
        
        /**
         * Test string method operations
         * Covers: .upper, .lower, .left, string concatenation
         */
        function testStringMethods() {
            const interpreter = new Interpreter();
            const vars = {
                first_name: 'John',
                last_name: 'Smith',
                count: 4
            };
            
            // Test string methods
            const firstInitial = interpreter.evaluateStringConcatenation('first_name.left(1)', vars);
            assertEqual(firstInitial, 'J', 'First name .left(1) should return "J"');
            
            const lastInitial = interpreter.evaluateStringConcatenation('last_name.left(1)', vars);
            assertEqual(lastInitial, 'S', 'Last name .left(1) should return "S"');
            
            const initials = interpreter.evaluateStringConcatenation('first_name.left(1) + last_name.left(1)', vars);
            assertEqual(initials, 'JS', 'Initials concatenation should return "JS"');
            
            assertEqual(interpreter.evaluateStringConcatenation('first_name.upper', vars), 'JOHN', 'String .upper method');
            assertEqual(interpreter.evaluateStringConcatenation('first_name.lower', vars), 'john', 'String .lower method');
        }
        
        /**
         * Test DIV and MOD operations (duck grouping)
         * Covers: integer division and remainder operations
         */
        function testDuckGrouping() {
            const interpreter = new Interpreter();
            
            // Test duck grouping scenarios
            assertEqual(interpreter.evaluateArithmeticExpression('15 DIV 4', {}), 3, 'Duck Grouping DIV (15 DIV 4 = 3)');
            assertEqual(interpreter.evaluateArithmeticExpression('15 MOD 4', {}), 3, 'Duck Grouping MOD (15 MOD 4 = 3)');
            assertEqual(interpreter.evaluateArithmeticExpression('22 DIV 4', {}), 5, 'Duck Grouping DIV (22 DIV 4 = 5)');
            assertEqual(interpreter.evaluateArithmeticExpression('22 MOD 4', {}), 2, 'Duck Grouping MOD (22 MOD 4 = 2)');
        }
        
        /**
         * Test for loop execution
         * Covers: loop variables, trace entries, output generation
         */
        function testForLoopExecution() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: [], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                for x = 0 to 2
                    print(x*2)
                next x
            `, testProgram);
            
            // Check variables and outputs
            assertEqual(testInterpreter.variables.x, 2, 'x should be 2 after loop completion');
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], '0', 'First output should be "0"');
            assertEqual(testInterpreter.outputs[1], '2', 'Second output should be "2"');
            assertEqual(testInterpreter.outputs[2], '4', 'Third output should be "4"');
        }
        
        /**
         * Test variable operations and expressions
         * Covers: variable access, numeric literals, expression evaluation
         */
        function testVariableOperations() {
            const interpreter = new Interpreter();
            const vars = { 
                x: 10, 
                y: 0,
                temp: 5
            };
            
            // Test variable access
            assertEqual(interpreter.getExpressionValue('x', vars), 10, 'Variable Access (x = 10)');
            assertEqual(interpreter.getExpressionValue('temp', vars), 5, 'Variable Access (temp = 5)');
            
            // Test numeric literals
            assertEqual(interpreter.getExpressionValue('42', vars), 42, 'Numeric Literal (42)');
            assertEqual(interpreter.getExpressionValue('0', vars), 0, 'Numeric Literal (0)');
        }
        
        /**
         * Test complex expressions
         * Covers: multi-operator expressions, nested operations
         */
        function testComplexExpressions() {
            const interpreter = new Interpreter();
            const vars = { 
                a: 2, 
                b: 3, 
                c: 4,
                nums: [1, 2, 3, 4, 5],
                index: 2
            };
            
            // Test complex arithmetic expression
            assertEqual(interpreter.evaluateArithmeticExpression('a * b + c * (a + b) - nums[index]', vars), 23, 
                'Complex Expression (2 * 3 + 4 * (2 + 3) - 3 = 23)');
            
            // Test expression with multiple operators
            assertEqual(interpreter.evaluateArithmeticExpression('a ^ b + c / a * nums[0]', vars), 10, 
                'Multiple Operators (2 ^ 3 + 4 / 2 * 1 = 10)');
        }
        
        /**
         * Test edge cases and boundary conditions
         * Covers: division by one, multiplication by zero, array bounds
         */
        function testEdgeCases() {
            const interpreter = new Interpreter();
            const vars = { 
                zero: 0, 
                one: 1, 
                ten: 10,
                emptyArray: [],
                smallArray: [42]
            };
            
            // Test edge operations
            assertEqual(interpreter.evaluateArithmeticExpression('ten / one', vars), 10, 'Division by One (10 / 1 = 10)');
            assertEqual(interpreter.evaluateArithmeticExpression('ten * zero', vars), 0, 'Multiplication by Zero (10 * 0 = 0)');
            assertEqual(interpreter.evaluateArithmeticExpression('ten ^ zero', vars), 1, 'Power of Zero (10 ^ 0 = 1)');
            
            // Test array bounds (should return 0 for out of bounds)
            assertEqual(interpreter.getExpressionValue('emptyArray[0]', vars), 0, 'Empty Array Access (should return 0)');
            assertEqual(interpreter.getExpressionValue('smallArray[5]', vars), 0, 'Out of Bounds Array Access (should return 0)');
        }
        
        /**
         * Test type conversions
         * Covers: float(), int(), bool() type casting
         */
        function testTypeConversions() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: ["3.14", "2.5"], randomValue: undefined };
            
            // Test float conversion
            const result = testInterpreter.executeProgram(`
                x = float(input("Enter number"))
                print(x)
            `, testProgram);
            
            assertEqual(testInterpreter.variables.x, 3.14, 'float(input()) should convert "3.14" to 3.14');
        }
        
        /**
         * Test nested conditional execution
         * Covers: if/then/else logic, nested conditions
         */
        function testNestedConditionalExecution() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: ["2.5", "8"], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                jumpLength = float(input("Enter jump length"))
                yearGroup = float(input("Enter year group"))
                if jumpLength > 2 then
                    if yearGroup >= 10 then
                        result = "qualify"
                    else
                        result = "too young"
                    endif
                else
                    result = "not long enough"
                endif
            `, testProgram);
            
            assertEqual(testInterpreter.variables.jumpLength, 2.5, 'jumpLength should be 2.5');
            assertEqual(testInterpreter.variables.yearGroup, 8, 'yearGroup should be 8');
            assertEqual(testInterpreter.variables.result, "too young", 'Should execute inner else branch');
        }
        
        /**
         * Test string methods in print statements
         * Covers: string methods used directly in output
         */
        function testStringMethodsInPrint() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: ["hello", "WORLD"], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                name = input("Enter name")
                city = input("Enter city")
                print(name.upper)
                print(city.lower)
                print(name.length)
            `, testProgram);
            
            // Check variables and outputs
            assertEqual(testInterpreter.variables.name, 'hello', 'name should be "hello"');
            assertEqual(testInterpreter.variables.city, 'WORLD', 'city should be "WORLD"');
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], 'HELLO', 'First output should be "HELLO"');
            assertEqual(testInterpreter.outputs[1], 'world', 'Second output should be "world"');
            assertEqual(testInterpreter.outputs[2], '5', 'Third output should be "5"');
        }
        
        /**
         * Test substring with variable parameters
         * Covers: substring method with dynamic parameters
         */
        function testSubstringWithVariable() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: [], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                for x = 1 to 3
                    country = "France"
                    print(country.substring(x, 1))
                next x
            `, testProgram);
            
            // Check outputs - should extract characters at positions 1, 2, 3 (r, a, n)
            assertEqual(testInterpreter.variables.x, 3, 'x should be 3 after loop completion');
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], 'r', 'First output should be "r" (position 1)');
            assertEqual(testInterpreter.outputs[1], 'a', 'Second output should be "a" (position 2)');
            assertEqual(testInterpreter.outputs[2], 'n', 'Third output should be "n" (position 3)');
        }
        
        /**
         * Test comment handling
         * Covers: comments ignored in execution, proper line tracing
         */
        function testComments() {
            const testInterpreter = new Interpreter();
            
            const codeWithComments = `// This is a comment
x = 5
// Another comment here
y = 10
// Final comment
z = x + y`;
            
            const result = testInterpreter.execute(codeWithComments);
            
            // Verify that only assignment lines are traced, comments are ignored
            assertEqual(testInterpreter.variables.x, 5, 'x should be 5 despite comments');
            assertEqual(testInterpreter.variables.y, 10, 'y should be 10 despite comments');
            assertEqual(testInterpreter.variables.z, 15, 'z should be 15 (x + y)');
            assertEqual(testInterpreter.trace.length, 3, 'Should have exactly 3 trace entries (no comments traced)');
        }
        
        /**
         * Test boolean casting
         * Covers: bool() function with different input types
         */
        function testBoolCasting() {
            const testInterpreter = new Interpreter();
            
            const boolTestCode = `isTrue = bool("True")
isFalse = bool("False")
isZero = bool(0)
isOne = bool(1)`;
            
            const result = testInterpreter.execute(boolTestCode);
            
            assertEqual(testInterpreter.variables.isTrue, true, 'bool("True") should be true');
            assertEqual(testInterpreter.variables.isFalse, false, 'bool("False") should be false');
            assertEqual(testInterpreter.variables.isZero, false, 'bool(0) should be false');
            assertEqual(testInterpreter.variables.isOne, true, 'bool(1) should be true');
        }
        
        /**
         * Test constant declarations
         * Covers: const keyword, constant protection
         */
        function testConstants() {
            const testInterpreter = new Interpreter();
            
            const constCode = `const pi = 3.14159
const vat = 0.2
price = 100
total = price * (1 + vat)`;
            
            const result = testInterpreter.execute(constCode);
            
            assertEqual(testInterpreter.variables.pi, 3.14159, 'const pi should be 3.14159');
            assertEqual(testInterpreter.variables.vat, 0.2, 'const vat should be 0.2');
            assertEqual(testInterpreter.variables.total, 120, 'total should be 120 (100 * 1.2)');
        }
        
        
        // ============================================================================
        // TEST MANAGEMENT AND EXECUTION
        // ============================================================================
        
        /**
         * Reset test state for a fresh test run
         */
        function resetTestState() {
            testResults = [];
            testsPassed = 0;
            testsFailed = 0;
        }
        
        /**
         * Display comprehensive test summary
         */
        function displayTestSummary() {
            const summaryDiv = document.getElementById('testSummary');
            const passRate = testsPassed + testsFailed > 0 ? 
                Math.round((testsPassed / (testsPassed + testsFailed)) * 100) : 0;
            
            summaryDiv.innerHTML = `
                <div class="test-summary ${passRate === 100 ? 'all-pass' : 'has-failures'}">
                    <h2>üìä Unit Test Results</h2>
                    <p><strong>Passed:</strong> ${testsPassed} | <strong>Failed:</strong> ${testsFailed} | <strong>Pass Rate:</strong> ${passRate}%</p>
                    <p><em>Testing individual interpreter methods and language features</em></p>
                </div>
            `;
        }
        
        /**
         * Display categorized test results
         */
        function displayTestResults() {
            const resultsDiv = document.getElementById('testResults');
            
            // Group tests by category
            const testCategories = {
                'Basic Arithmetic': ['Basic Addition', 'Basic Subtraction', 'Basic Multiplication', 'Basic Division', 'Basic Modulo', 'Basic Exponentiation'],
                'Operator Precedence': ['Multiplication before Addition', 'Division before Subtraction', 'Exponentiation before Multiplication', 'Left-to-right'],
                'Parentheses': ['Basic Parentheses', 'Nested Parentheses', 'Rectangle Perimeter', 'Complex Parentheses'],
                'Array Access': ['Array Access with Variable Index', 'Array Access with Literal Index', 'Arithmetic with Array Access', 'Array Access in Multiplication'],
                'String Methods': ['First name .left(1)', 'Last name .left(1)', 'Initials concatenation', 'String .upper method', 'String .lower method'],
                'Duck Grouping': ['Duck Grouping DIV', 'Duck Grouping MOD'],
                'For Loop Execution': ['x should be 2', 'Should have exactly 3 outputs', 'First output should be "0"', 'Second output should be "2"', 'Third output should be "4"'],
                'Variable Operations': ['Variable Access', 'Numeric Literal'],
                'Complex Expressions': ['Complex Expression', 'Multiple Operators'],
                'Edge Cases': ['Division by One', 'Multiplication by Zero', 'Power of Zero', 'Empty Array Access', 'Out of Bounds Array Access'],
                'Type Conversions': ['float(input())'],
                'Nested Conditionals': ['jumpLength should be 2.5', 'yearGroup should be 8', 'Should execute inner else branch'],
                'String Methods in Print': ['name should be "hello"', 'city should be "WORLD"', 'Should have exactly 3 outputs'],
                'Substring with Variable': ['x should be 3 after loop completion', 'Should have exactly 3 outputs'],
                'Comments': ['x should be 5 despite comments', 'y should be 10 despite comments', 'z should be 15 (x + y)', 'Should have exactly 3 trace entries'],
                'Boolean Casting': ['bool("True") should be true', 'bool("False") should be false', 'bool(0) should be false', 'bool(1) should be true'],
                'Constants': ['const pi should be 3.14159', 'const vat should be 0.2', 'total should be 120 (100 * 1.2)'],
                'For Loops with Positive Step': ['Should have 5 outputs for step 2', 'First output should be "2"', 'Second output should be "4"', 'Fifth output should be "10"'],
                'For Loops with Negative Step': ['Should have 11 outputs for countdown', 'First output should be "10"', 'Eleventh output should be "0"'],
                'Switch/Case': ['day should be "Mon"', 'First output should be "Monday"', 'Second output should be "Done"']
            };
            
            let html = '';
            
            for (const [categoryName, prefixes] of Object.entries(testCategories)) {
                const categoryTests = testResults.filter(test => 
                    prefixes.some(prefix => test.name.includes(prefix))
                );
                
                if (categoryTests.length > 0) {
                    html += `<div class="test-section">`;
                    html += `<h2>${categoryName}</h2>`;
                    
                    for (const test of categoryTests) {
                        const cssClass = test.passed ? 'test-pass' : 'test-fail';
                        const status = test.passed ? '‚úÖ PASS' : '‚ùå FAIL';
                        html += `<div class="test-result ${cssClass}">`;
                        html += `<strong>${status}</strong> - ${test.name}`;
                        if (test.details) {
                            html += `<div class="test-details">${test.details}</div>`;
                        }
                        html += `</div>`;
                    }
                    
                    html += `</div>`;
                }
            }
            
            resultsDiv.innerHTML = html;
            
            // Default to hiding passed tests
            const container = document.querySelector('.container');
            const toggleBtn = document.getElementById('togglePassedBtn');
            
            container.classList.add('hide-passed');
            const passedCount = document.querySelectorAll('.test-result.test-pass').length;
            toggleBtn.textContent = `üëÅÔ∏è Show Passed Tests (${passedCount} hidden)`;
            toggleBtn.classList.add('active');
            
            displayTestSummary();
        }
        
        /**
         * Toggle visibility of passed tests
         */
        function togglePassedTests() {
            const container = document.querySelector('.container');
            const toggleBtn = document.getElementById('togglePassedBtn');
            const passedCount = document.querySelectorAll('.test-result.test-pass').length;
            
            if (container.classList.contains('hide-passed')) {
                container.classList.remove('hide-passed');
                toggleBtn.textContent = 'üôà Hide Passed Tests';
                toggleBtn.classList.remove('active');
            } else {
                container.classList.add('hide-passed');
                toggleBtn.textContent = `üëÅÔ∏è Show Passed Tests (${passedCount} hidden)`;
                toggleBtn.classList.add('active');
            }
        }
        
        /**
         * Set up keyboard shortcuts for test management
         */
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(event) {
                if (event.key === 'h' || event.key === 'H') {
                    togglePassedTests();
                } else if (event.key === 'r' || event.key === 'R') {
                    runAllTests();
                }
            });
        }
        
        /**
         * Run all unit tests
         */
        function runAllTests() {
            // Reset state
            resetTestState();
            
            // Run all test categories
            testBasicArithmetic();
            testOperatorPrecedence();
            testParentheses();
            testArrayAccess();
            testStringMethods();
            testDuckGrouping();
            testForLoopExecution();
            testVariableOperations();
            testComplexExpressions();
            testEdgeCases();
            testTypeConversions();
            testNestedConditionalExecution();
            testStringMethodsInPrint();
            testSubstringWithVariable();
            testComments();
            testBoolCasting();
            testConstants();
            testForLoopWithPositiveStep();
            testForLoopWithNegativeStep();
            testSwitchCase();
            
            // Display results
            displayTestResults();
            
            console.log(`‚úÖ Unit tests completed: ${testsPassed} passed, ${testsFailed} failed`);
        }
        
        // Make functions available globally
        window.runAllTests = runAllTests;
        window.togglePassedTests = togglePassedTests;
        
        // Auto-run tests on page load
        document.addEventListener('DOMContentLoaded', function() {
            setupKeyboardShortcuts();
            runAllTests();
        });
    </script>
</body>
</html>
