<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>🦆 Mr Luther's OCR J277 Trace Table Practice 🦆</title>
    <link rel="icon" href="favicon.svg" type="image/svg+xml">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            color: white;
            padding: 20px 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        .btn-success {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(72, 187, 120, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
            color: white;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(237, 137, 54, 0.4);
        }

        .difficulty-selector,
        .mode-selector,
        .program-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .difficulty-selector label,
        .mode-selector label,
        .program-selector label {
            font-weight: 600;
            color: #2d3748;
        }

        .difficulty-selector select,
        .mode-selector select,
        .program-selector select {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .code-section {
            background: #1a202c;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .code-section h3 {
            color: #90cdf4;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .code-display {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #e2e8f0;
            background: #2d3748;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            white-space: pre;
        }

        .line-number {
            color: #90cdf4;
            margin-right: 15px;
            user-select: none;
        }

        .trace-section {
            margin-bottom: 30px;
        }

        .trace-section h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .trace-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .trace-table th {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: white;
            padding: 12px;
            text-align: center;
            font-weight: 600;
        }

        .trace-table td {
            padding: 10px;
            text-align: center;
            border-bottom: 1px solid #e2e8f0;
        }

        .trace-table input {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            text-align: center;
            font-size: 14px;
        }

        .trace-table input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .trace-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }

        .feedback.success {
            background: #c6f6d5;
            color: #2f855a;
            border: 1px solid #9ae6b4;
        }

        .feedback.error {
            background: #fed7d7;
            color: #c53030;
            border: 1px solid #feb2b2;
        }

        .score {
            font-size: 1.2em;
            font-weight: 600;
            text-align: center;
            margin-top: 10px;
        }

        .instructions {
            background: #edf2f7;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
        }

        .instructions-header {
            color: #2d3748;
            margin-bottom: 10px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: color 0.2s ease;
        }

        .instructions-header:hover {
            color: #667eea;
        }

        .instructions-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
            max-height: 200px; /* Initial expanded height */
        }

        .instructions-content.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        .instructions h4 {
            color: #2d3748;
            margin-bottom: 10px;
        }

        .instructions ul {
            color: #4a5568;
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .difficulty-selector {
                justify-content: center;
            }
            
            .code-display {
                font-size: 12px;
            }
            
            .trace-table {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎯 Mr Luther's OCR J277 Trace Table Practice Page</h1>
            <p>Practice coding in OCR ERL <a href="https://www.examreferencelanguage.co.uk/"> here </a></p>
        </div>

        <div class="content">
            <div class="instructions">
                <h4 class="instructions-header" onclick="toggleInstructions()">
                    📋 Instructions: <span id="instructions-toggle">▼</span>
                </h4>
                <div id="instructions-content" class="instructions-content">
                    <ul>
                        <li>Select difficulty level (Easy/Medium/Hard)</li>
                        <li>Choose between "Random" mode or "Select Program" mode</li>
                        <li>In Select mode, choose a specific program from the dropdown</li>
                        <li>Click "Generate" to try your chosen program</li>
                        <li>Trace through the code step by step</li>
                        <li>Fill in the trace table with variable values and outputs</li>
                        <li>Click "Mark Answer" to check your solution</li>
                        <li>Use "Clear Table" to reset all inputs if needed</li>
                    </ul>
                </div>
            </div>

            <div class="controls">
                <div class="difficulty-selector">
                    <label for="difficulty">Difficulty:</label>
                    <select id="difficulty" onchange="updateProgramSelector()">
                        <option value="easy">Easy</option>
                        <option value="medium">Medium</option>
                        <option value="hard">Hard</option>
                    </select>
                </div>
                <div class="mode-selector">
                    <label for="mode">Mode:</label>
                    <select id="mode" onchange="toggleProgramSelector()">
                        <option value="random">Random</option>
                        <option value="select">Select Program</option>
                    </select>
                </div>
                <div class="program-selector" id="programSelector" style="display: none;">
                    <label for="programChoice">Program:</label>
                    <select id="programChoice">
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>
                <button class="btn btn-primary" onclick="generateProgram()">🔄 Generate</button>
            </div>

            <div class="code-section">
                <h3>💻 Program Code</h3>
                <div class="code-display" id="codeDisplay">
                    Click "Generate" to start!
                </div>
            </div>

            <div class="trace-section">
                <h3>📊 Trace Table</h3>
                <table class="trace-table" id="traceTable">
                    <thead>
                        <tr>
                            <th>Line Number</th>
                            <th>Output</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Table rows will be generated dynamically -->
                    </tbody>
                </table>
                
                <div class="table-controls" style="margin-top: 20px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <button class="btn btn-success" onclick="markAnswer()">✅ Mark Answer</button>
                    <button class="btn btn-warning" onclick="clearTable()">🗑️ Clear Table</button>
                </div>
            </div>

            <div class="feedback" id="feedback">
                <div class="score" id="score"></div>
                <div id="feedbackText"></div>
            </div>
        </div>
    </div>

    <script>
        let currentProgram = null;
        let expectedTrace = [];
        let programVariables = [];

        // Toggle instructions visibility
        function toggleInstructions() {
            const content = document.getElementById('instructions-content');
            const toggle = document.getElementById('instructions-toggle');
            
            if (content.classList.contains('collapsed')) {
                // Expand
                content.classList.remove('collapsed');
                content.style.maxHeight = content.scrollHeight + 'px';
                toggle.textContent = '▼';
            } else {
                // Collapse
                content.style.maxHeight = '0px';
                content.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }

        // Initialize instructions as expanded with proper max-height
        document.addEventListener('DOMContentLoaded', function() {
            const content = document.getElementById('instructions-content');
            // Set initial max-height to the actual content height
            content.style.maxHeight = content.scrollHeight + 'px';
        });

        const programs = {
            easy: [
                {
                    code: `a = 5
b = 3
c = a + b
print(c)`,
                    description: "Simple arithmetic"
                },
                {
                    code: `name = "Alice"
age = 16
print("Hello " + name)
print("You are " + str(age))`,
                    description: "String concatenation"
                },
                {
                    code: `x = 10
y = 20
temp = x
x = y
y = temp
print(x)
print(y)`,
                    description: "Variable swapping"
                },
                {
                    code: `name = input("What's your name?")
print("Hello " + name)`,
                    description: "Simple input and output",
                    inputSets: [
                        ["Alice"],
                        ["Bob"],
                        ["Charlie"],
                        ["Diana"]
                    ]
                },
                {
                    code: `age = int(input("How old are you?"))
if age < 18 then
    print("You are a student!")
else
    print("You finished school")
endif`,
                    description: "Age checker with conditions",
                    inputSets: [
                        ["16"],
                        ["20"],
                        ["17"],
                        ["25"]
                    ]
                },
                {
                    code: `test1 = int(input("What score?"))
test2 = int(input("What score?"))
total = test1 + test2
print("You got " + str(total))`,
                    description: "Adding two test scores",
                    inputSets: [
                        ["75", "82"],
                        ["90", "88"],
                        ["65", "70"],
                        ["95", "92"]
                    ]
                },
                {
                    code: `price = int(input("Enter price"))
discount = price / 10
final_price = price - discount
print("Original: " + str(price))
print("Final: " + str(final_price))`,
                    description: "Calculate 10% discount",
                    inputSets: [
                        ["50"],
                        ["100"],
                        ["80"],
                        ["120"]
                    ]
                },
                {
                    code: `length = int(input("Length"))
width = int(input("Width"))
area = length * width
perimeter = 2 * (length + width)
print("Area: " + str(area))
print("Perimeter: " + str(perimeter))`,
                    description: "Rectangle calculations",
                    inputSets: [
                        ["5", "3"],
                        ["10", "8"],
                        ["12", "4"],
                        ["7", "6"]
                    ]
                },
                {
                    code: `temperature = int(input("Temperature in Celsius"))
if temperature > 25 then
    print("It's warm today")
else
    print("It's cool today")
endif
print(str(temperature) + " degrees C")`,
                    description: "Temperature feedback with condition",
                    inputSets: [
                        ["30"],
                        ["20"],
                        ["15"],
                        ["28"]
                    ]
                },
                {
                    code: `hours = int(input("Hours worked"))
rate = 10
pay = hours * rate
if hours > 40 then
    bonus = 50
    pay = pay + bonus
    print("Bonus earned!")
endif
print("Total pay: " + str(pay))`,
                    description: "Pay calculator with bonus",
                    inputSets: [
                        ["35"],
                        ["45"],
                        ["40"],
                        ["50"]
                    ]
                },
                {
                    code: `first_name = input("First name")
last_name = input("Last name")
full_name = first_name + " " + last_name
initials = first_name.left(1) + last_name.left(1)
print("Full name: " + full_name)
print("Initials: " + initials)`,
                    description: "Name processing with string methods",
                    inputSets: [
                        ["John", "Smith"],
                        ["Emma", "Jones"],
                        ["Alex", "Brown"],
                        ["Sarah", "Wilson"]
                    ]
                }
            ],
            medium: [
                {
                    code: `total = 0
for i = 1 to 3
    total = total + i
    print(total)
next i
print("Final: " + str(total))`,
                    description: "For loop with accumulator"
                },
                {
                    code: `count = 0
while count < 3
    count = count + 1
    print("Count: " + str(count))
endwhile
print("Finished counting")`,
                    description: "While loop with counter"
                },
                {
                    code: `score = 75
if score >= 90 then
    print("Grade A")
elseif score >= 70 then
    print("Grade B")
else
    print("Grade C")
endif
print("Score: " + str(score))`,
                    description: "If-elseif-else statements"
                },
                {
                    code: `surname = input("Enter surname")
year = input("Enter starting year")
staffID = surname + str(year)
while staffID.length < 10
    staffID = staffID + "x"
endwhile
print("ID " + staffID)`,
                    description: "Staff ID generator with input",
                    inputSets: [
                        ["Kofi", "2021"],
                        ["Smith", "2023"],
                        ["Lee", "2020"],
                        ["Brown", "2024"]
                    ]
                },
                {
                    code: `x = 15
y = 0
while x > 0
    y = y + 1
    x = x - y
endwhile
print(y)`,
                    description: "While loop with variable decrement"
                },
                {
                    code: `a = input("Enter first letter of first name")
b = input("Enter first letter of second name")
c = random(1,100)
while c < 100
    c = c * 10
endwhile
pilotCode = a + b + str(c)
print(pilotCode)`,
                    description: "Pilot code generator with random",
                    inputSets: [
                        ["S", "T"],
                        ["A", "B"],
                        ["J", "M"],
                        ["K", "R"]
                    ],
                    randomValues: [4, 7, 12, 25, 50]
                },
                {
                    code: `jumpLength = input("Enter jump length")
yearGroup = input("Enter year group")
if jumpLength > 2 then
    if yearGroup >= 10 then
        print("You qualify for the team")
    else
        print("You are too young")
    endif
else
    print("Jump not long enough")
endif`,
                    description: "Long jump qualification",
                    inputSets: [
                        ["2.5", "9"],
                        ["3.1", "11"],
                        ["1.8", "10"],
                        ["2.2", "8"]
                    ]
                },
                {
                    code: `longJump = input("Enter distance")
yearGroup = input("Enter year group")
if longJump >= 5.0 then
    score = 3
elseif longJump >= 3.0 then
    score = 2
else
    score = 1
endif
if yearGroup != 10 then
    score = score * 2
endif
print("The score is", score)`,
                    description: "Long jump scoring system",
                    inputSets: [
                        ["2.5", "9"],
                        ["5.2", "10"],
                        ["3.8", "11"],
                        ["1.9", "8"]
                    ]
                },
                {
                    code: `for x = 0 to 2
    print(x*2)
next x`,
                    description: "For loop with multiplication"
                },
                {
                    code: `for x = 0 to 5
    if x < 3 then
        print("less than 3")
    else
        print("3 or above")
    endif
next x`,
                    description: "For loop with conditional output"
                },
                {
                    code: `for x = 0 to 2
    choice = input("Enter a word")
    case = input("upper or lower")
    if case == "upper" then
        print(choice.upper)
    else
        print(choice.lower)
    endif
next x`,
                    description: "For loop with string methods",
                    inputSets: [
                        ["hello", "upper", "world", "lower", "test", "upper"],
                        ["cat", "lower", "DOG", "upper", "fish", "lower"],
                        ["APPLE", "lower", "banana", "upper", "Orange", "lower"],
                        ["yes", "upper", "NO", "lower", "maybe", "upper"]
                    ]
                },
                {
                    code: `for x = 1 to 3
    country = "France"
    print(country[x])
next x`,
                    description: "Array indexing with string"
                },
                {
                    code: `for x = 1 to 4
    if x < 3 then
        print("it's Jeff")    
    else
        num = int(input("Enter a number"))
        print(x * num)
    endif
next x`,
                    description: "For loop with conditional input",
                    inputSets: [
                        ["5", "8"],
                        ["3", "10"],
                        ["7", "4"],
                        ["2", "6"]
                    ]
                },
                {
                    code: `for x = 1 to 3
    name = input("Enter a name")
    length = name.length
    print(x * length)
next x`,
                    description: "For loop with string length calculation",
                    inputSets: [
                        ["Alice", "Bob", "Charlie"],
                        ["Sam", "Jennifer", "Alex"],
                        ["Jo", "Michael", "Diana"],
                        ["Max", "Catherine", "Tom"]
                    ]
                },
                {
                    code: `for x = 1 to 3
    country = "United Kingdom"     
    num = int(input("Enter a number"))
    letter = country[num]
    print(country[x] + letter)
next x`,
                    description: "For loop with string indexing",
                    inputSets: [
                        ["2", "5", "8"],
                        ["0", "7", "3"],
                        ["4", "1", "9"],
                        ["6", "10", "2"]
                    ]
                },
                {
                    code: `for x = 1 to 4
    num = int(input("Enter a number"))
    operator = input("Enter operator")
    if operator == "%" then
        print(num MOD x)
    else
        print(num*x)
    endif
next x`,
                    description: "For loop with operator selection",
                    inputSets: [
                        ["10", "%", "15", "*", "8", "%", "20", "*"],
                        ["12", "*", "8", "%", "14", "*", "6", "%"],
                        ["16", "%", "10", "*", "6", "%", "15", "*"],
                        ["14", "*", "16", "%", "5", "*", "20", "%"]
                    ]
                },
                {
                    code: `ducks = int(input("How many ducks are there"))
groups = ducks DIV 4
leftOver = ducks MOD 4
print("Number of groups: " + str(groups))
print("Ducks left over: " + str(leftOver))`,
                    description: "Duck grouping with MOD and DIV operators",
                    inputSets: [
                        ["15"],
                        ["22"],
                        ["8"],
                        ["13"],
                        ["20"],
                        ["7"]
                    ]
                }
            ],
            hard: [
                {
                    code: `array nums[3]
nums[0] = 10
nums[1] = 20
nums[2] = 30
total = 0
for i = 0 to 2
    total = total + nums[i]
    print("Sum so far: " + str(total))
next i
print("Average: " + str(total / 3))`,
                    description: "Array processing"
                },
                {
                    code: `do
    x = input("Password: ")
    print("You guessed " + x)
until x == "parrot"
print("Correct!")`,
                    description: "Do-until loop with password check",
                    inputSets: [
                        ["hello", "123", "parrot"],
                        ["password", "parrot"],
                        ["wrong", "guess", "test", "parrot"],
                        ["abc", "parrot"]
                    ]
                }
            ]
        };

        function generateProgram() {
            const difficulty = document.getElementById('difficulty').value;
            const mode = document.getElementById('mode').value;
            const programList = programs[difficulty];
            
            let randomProgram;
            
            if (mode === 'select') {
                const selectedIndex = parseInt(document.getElementById('programChoice').value);
                randomProgram = programList[selectedIndex];
            } else {
                // Random mode
                randomProgram = programList[Math.floor(Math.random() * programList.length)];
            }
            
            currentProgram = { ...randomProgram };
            
            // If the program has multiple input sets, randomly select one
            if (currentProgram.inputSets && currentProgram.inputSets.length > 0) {
                const randomInputSet = currentProgram.inputSets[Math.floor(Math.random() * currentProgram.inputSets.length)];
                currentProgram.inputs = randomInputSet;
            }
            
            // If the program has multiple random values, randomly select one
            if (currentProgram.randomValues && currentProgram.randomValues.length > 0) {
                const randomValue = currentProgram.randomValues[Math.floor(Math.random() * currentProgram.randomValues.length)];
                currentProgram.randomValue = randomValue;
            }
            
            displayCode(currentProgram.code);
            executeProgram(currentProgram.code);
            createTraceTable();
            
            // Hide feedback
            document.getElementById('feedback').style.display = 'none';
        }

        function displayCode(code) {
            const lines = code.split('\n');
            let numberedCode = '';
            
            lines.forEach((line, index) => {
                numberedCode += `<span class="line-number">${index + 1}</span>${line}\n`;
            });
            
            // Add input values display if available
            if (currentProgram.inputs && currentProgram.inputs.length > 0) {
                numberedCode += `\n<span style="color: #90cdf4;">Input values: ${currentProgram.inputs.map(input => `"${input}"`).join(', ')}</span>`;
            }
            
            // Add random value display if available
            if (currentProgram.randomValue !== undefined) {
                numberedCode += `\n<span style="color: #90cdf4;">Random value: ${currentProgram.randomValue}</span>`;
            }
            
            document.getElementById('codeDisplay').innerHTML = numberedCode;
        }

        function executeProgram(code) {
            // Simple interpreter for trace table generation
            const lines = code.split('\n').map(line => line.trim()).filter(line => line);
            const variables = {};
            const outputs = [];
            const trace = [];
            
            // Get predefined inputs if available
            const inputs = currentProgram.inputs || [];
            let inputIndex = 0;
            
            function addTraceEntry(lineNum, vars, output = '') {
                trace.push({
                    lineNumber: lineNum,
                    variables: { ...vars },
                    output: output
                });
            }
            
            function getVariableValue(operand, vars) {
                // Helper function to get value from variable or array access
                if (operand.includes('[') && operand.includes(']')) {
                    // Array access like nums[i]
                    const arrayMatch = operand.match(/(\w+)\[(\w+)\]/);
                    if (arrayMatch) {
                        const arrayName = arrayMatch[1];
                        const indexVar = arrayMatch[2];
                        
                        if (vars[arrayName] && Array.isArray(vars[arrayName]) && vars[indexVar] !== undefined) {
                            const index = parseInt(vars[indexVar]);
                            if (index >= 0 && index < vars[arrayName].length) {
                                return vars[arrayName][index];
                            }
                        }
                    }
                    return undefined;
                } else {
                    return vars[operand];
                }
            }

            function evaluateArithmeticExpression(expression, vars) {
                // Normalize whitespace around word operators
                expression = expression.replace(/\s*\bMOD\b\s*/g, ' MOD ');
                expression = expression.replace(/\s*\bDIV\b\s*/g, ' DIV ');
                
                // Clean up multiple spaces
                expression = expression.replace(/\s+/g, ' ').trim();
                
                // Handle parentheses by recursively evaluating inner expressions
                while (expression.includes('(')) {
                    let depth = 0;
                    let start = -1;
                    
                    for (let i = 0; i < expression.length; i++) {
                        if (expression[i] === '(') {
                            if (depth === 0) start = i;
                            depth++;
                        } else if (expression[i] === ')') {
                            depth--;
                            if (depth === 0) {
                                const innerExpr = expression.substring(start + 1, i);
                                const result = evaluateArithmeticExpression(innerExpr, vars);
                                expression = expression.substring(0, start) + result + expression.substring(i + 1);
                                break;
                            }
                        }
                    }
                }
                
                // Handle operators in order of precedence
                // First handle ^ (exponentiation) - right to left
                while (expression.includes('^')) {
                    const lastPos = expression.lastIndexOf('^');
                    const leftPart = expression.substring(0, lastPos);
                    const rightPart = expression.substring(lastPos + 1);
                    
                    // Find left operand (skip spaces)
                    let leftOperand = '';
                    let i = leftPart.length - 1;
                    // Skip spaces before operand
                    while (i >= 0 && leftPart[i] === ' ') i--;
                    // Collect operand characters
                    while (i >= 0 && /[A-Za-z0-9_]/.test(leftPart[i])) {
                        leftOperand = leftPart[i] + leftOperand;
                        i--;
                    }
                    
                    // Find right operand (skip spaces)
                    let rightOperand = '';
                    let j = 0;
                    // Skip spaces after operator
                    while (j < rightPart.length && rightPart[j] === ' ') j++;
                    // Collect operand characters
                    while (j < rightPart.length && /[A-Za-z0-9_]/.test(rightPart[j])) {
                        rightOperand += rightPart[j];
                        j++;
                    }
                    
                    const leftVal = getExpressionValue(leftOperand, vars);
                    const rightVal = getExpressionValue(rightOperand, vars);
                    const result = Math.pow(leftVal, rightVal);
                    
                    // Replace the entire operation with the result
                    const beforeLeft = leftPart.substring(0, i + 1);
                    const afterRight = rightPart.substring(j);
                    expression = beforeLeft + result + afterRight;
                }
                
                // Then handle *, /, DIV, MOD (left to right)
                expression = handleLeftToRightOperators(expression, ['*', '/', 'DIV', 'MOD'], vars);
                
                // Finally handle +, - (left to right)
                expression = handleLeftToRightOperators(expression, ['+', '-'], vars);
                
                // At this point, expression should be a single value
                return getExpressionValue(expression, vars);
            }
            
            function getExpressionValue(operand, vars) {
                // Handle array access
                if (operand.includes('[') && operand.includes(']')) {
                    const arrayMatch = operand.match(/(\w+)\[(\w+)\]/);
                    if (arrayMatch) {
                        const arrayName = arrayMatch[1];
                        const indexVar = arrayMatch[2];
                        
                        if (vars[arrayName] && Array.isArray(vars[arrayName])) {
                            const index = vars[indexVar] !== undefined ? parseInt(vars[indexVar]) : parseInt(indexVar);
                            if (index >= 0 && index < vars[arrayName].length) {
                                return vars[arrayName][index];
                            }
                        }
                    }
                    return 0;
                }
                
                // Handle regular variables
                if (vars[operand] !== undefined) {
                    return parseInt(vars[operand]);
                }
                
                // Handle numeric literals
                if (!isNaN(operand)) {
                    return parseInt(operand);
                }
                
                return 0;
            }
            
            function handleLeftToRightOperators(expression, operators, vars) {
                let changed = true;
                while (changed) {
                    changed = false;
                    
                    // Find the leftmost operator from our list
                    let earliestPos = expression.length;
                    let earliestOp = null;
                    let earliestLength = 0;
                    
                    for (const op of operators) {
                        let pos = 0;
                        while (pos < expression.length) {
                            if (op === 'DIV' || op === 'MOD') {
                                // Find whole word operators
                                pos = expression.indexOf(op, pos);
                                if (pos === -1) break;
                                
                                // Check if it's a whole word (not part of another word)
                                if ((pos === 0 || !/[A-Za-z0-9_]/.test(expression[pos - 1])) &&
                                    (pos + op.length === expression.length || !/[A-Za-z0-9_]/.test(expression[pos + op.length]))) {
                                    if (pos < earliestPos) {
                                        earliestPos = pos;
                                        earliestOp = op;
                                        earliestLength = op.length;
                                    }
                                    break;
                                }
                                pos++;
                            } else {
                                pos = expression.indexOf(op, pos);
                                if (pos === -1) break;
                                
                                if (pos < earliestPos) {
                                    earliestPos = pos;
                                    earliestOp = op;
                                    earliestLength = 1;
                                }
                                break;
                            }
                        }
                    }
                    
                    if (earliestOp && earliestPos < expression.length) {
                        // Find left operand (skip spaces)
                        let leftStart = earliestPos - 1;
                        while (leftStart >= 0 && expression[leftStart] === ' ') {
                            leftStart--; // Skip spaces
                        }
                        let leftEnd = leftStart + 1;
                        while (leftStart >= 0 && /[A-Za-z0-9_\[\]]/.test(expression[leftStart])) {
                            leftStart--;
                        }
                        leftStart++;
                        
                        // Find right operand (skip spaces)
                        let rightStart = earliestPos + earliestLength;
                        while (rightStart < expression.length && expression[rightStart] === ' ') {
                            rightStart++; // Skip spaces
                        }
                        let rightEnd = rightStart;
                        while (rightEnd < expression.length && /[A-Za-z0-9_\[\]]/.test(expression[rightEnd])) {
                            rightEnd++;
                        }
                        
                        const leftOperand = expression.substring(leftStart, leftEnd).trim();
                        const rightOperand = expression.substring(rightStart, rightEnd).trim();
                        
                        if (leftOperand && rightOperand) {
                            const leftVal = getExpressionValue(leftOperand, vars);
                            const rightVal = getExpressionValue(rightOperand, vars);
                            let result;
                            
                            switch (earliestOp) {
                                case '+':
                                    result = leftVal + rightVal;
                                    break;
                                case '-':
                                    result = leftVal - rightVal;
                                    break;
                                case '*':
                                    result = leftVal * rightVal;
                                    break;
                                case '/':
                                    result = Math.floor(leftVal / rightVal);
                                    break;
                                case 'DIV':
                                    result = Math.floor(leftVal / rightVal);
                                    break;
                                case 'MOD':
                                    result = leftVal % rightVal;
                                    break;
                            }
                            
                            // Replace the entire operation (from leftStart to rightEnd) with the result
                            const beforeOperation = expression.substring(0, leftStart);
                            const afterOperation = expression.substring(rightEnd);
                            expression = beforeOperation + result + afterOperation;
                            changed = true;
                        }
                    }
                }
                
                return expression;
            }
            
            function executeStatement(line, lineNum, vars) {
                let output = '';
                let shouldTrace = true; // Flag to determine if this line should be traced
                
                if (line.startsWith('array ')) {
                    // Array declaration like "array nums[3]"
                    const match = line.match(/array\s+(\w+)\[(\d+)\]/);
                    if (match) {
                        const arrayName = match[1];
                        const arraySize = parseInt(match[2]);
                        // Initialize array with undefined values
                        vars[arrayName] = new Array(arraySize);
                        for (let i = 0; i < arraySize; i++) {
                            vars[arrayName][i] = undefined;
                        }
                        shouldTrace = false; // Don't trace array declarations
                    }
                } else if (line.includes('=') && !line.includes('==') && !line.includes('!=') && !line.includes('<=') && !line.includes('>=')) {
                    // Assignment
                    const parts = line.split('=');
                    const varName = parts[0].trim();
                    const value = parts[1].trim();
                    
                    // Check if this is an array element assignment like "nums[0] = 10"
                    if (varName.includes('[') && varName.includes(']')) {
                        const arrayMatch = varName.match(/(\w+)\[(\d+)\]/);
                        if (arrayMatch) {
                            const arrayName = arrayMatch[1];
                            const index = parseInt(arrayMatch[2]);
                            
                            if (vars[arrayName] && Array.isArray(vars[arrayName])) {
                                if (!isNaN(value)) {
                                    vars[arrayName][index] = parseInt(value);
                                } else if (value.startsWith('"') && value.endsWith('"')) {
                                    vars[arrayName][index] = value.slice(1, -1);
                                } else if (vars[value] !== undefined) {
                                    vars[arrayName][index] = vars[value];
                                }
                            }
                        }
                    } else if (value.startsWith('input(')) {
                        // Input statement - use predefined input value
                        if (inputIndex < inputs.length) {
                            vars[varName] = inputs[inputIndex];
                            inputIndex++;
                        } else {
                            vars[varName] = "undefined_input";
                        }
                    } else if (value.startsWith('int(input(')) {
                        // int(input()) statement - use predefined input value and convert to integer
                        if (inputIndex < inputs.length) {
                            vars[varName] = parseInt(inputs[inputIndex]);
                            inputIndex++;
                        } else {
                            vars[varName] = 0;
                        }
                    } else if (value.startsWith('random(')) {
                        // Random function - use predefined random value if available
                        if (currentProgram.randomValue !== undefined) {
                            vars[varName] = currentProgram.randomValue;
                        } else {
                            // Parse the random range and use the minimum value for consistency
                            const match = value.match(/random\((\d+),\s*(\d+)\)/);
                            if (match) {
                                const min = parseInt(match[1]);
                                vars[varName] = min; // Use minimum for deterministic results
                            } else {
                                vars[varName] = 1; // Default fallback
                            }
                        }
                    } else if (value.startsWith('"') && value.endsWith('"')) {
                        vars[varName] = value.slice(1, -1);
                    } else if (value.includes('.length')) {
                        const sourceVar = value.split('.')[0];
                        if (vars[sourceVar] !== undefined) {
                            vars[varName] = vars[sourceVar].toString().length;
                        }
                    } else if (value.includes('.left(')) {
                        const match = value.match(/(\w+)\.left\((\d+)\)/);
                        if (match && vars[match[1]] !== undefined) {
                            const sourceVar = match[1];
                            const length = parseInt(match[2]);
                            vars[varName] = vars[sourceVar].toString().substring(0, length);
                        }
                    } else if (value.includes('.right(')) {
                        const match = value.match(/(\w+)\.right\((\d+)\)/);
                        if (match && vars[match[1]] !== undefined) {
                            const sourceVar = match[1];
                            const length = parseInt(match[2]);
                            const str = vars[sourceVar].toString();
                            vars[varName] = str.substring(str.length - length);
                        }
                    } else if (value.includes('.substring(')) {
                        const match = value.match(/(\w+)\.substring\((\d+),\s*(\d+)\)/);
                        if (match && vars[match[1]] !== undefined) {
                            const sourceVar = match[1];
                            const start = parseInt(match[2]);
                            const length = parseInt(match[3]);
                            vars[varName] = vars[sourceVar].toString().substring(start, start + length);
                        }
                    } else if (!isNaN(value)) {
                        vars[varName] = parseInt(value);
                    } else {
                        // Expression evaluation - check if it's string concatenation first
                        if (value.includes('+') && 
                            (value.includes('"') || 
                             value.split('+').some(op => {
                                 const trimmed = op.trim();
                                 return vars[trimmed] !== undefined && typeof vars[trimmed] === 'string';
                             }))) {
                            // String concatenation
                            const operands = value.split('+').map(op => op.trim());
                            let result = '';
                            
                            operands.forEach(op => {
                                if (op.startsWith('"') && op.endsWith('"')) {
                                    result += op.slice(1, -1);
                                } else if (getVariableValue(op, vars) !== undefined) {
                                    result += getVariableValue(op, vars).toString();
                                } else if (vars[op] !== undefined) {
                                    result += vars[op].toString();
                                } else if (op.startsWith('str(') && op.endsWith(')')) {
                                    const varName = op.substring(4, op.length - 1);
                                    if (vars[varName] !== undefined) {
                                        result += vars[varName].toString();
                                    }
                                } else if (op.includes('.length')) {
                                    const varName = op.split('.')[0];
                                    if (vars[varName] !== undefined) {
                                        result += vars[varName].toString().length.toString();
                                    }
                                } else if (op.includes('.left(')) {
                                    const match = op.match(/(\w+)\.left\((\d+)\)/);
                                    if (match && vars[match[1]] !== undefined) {
                                        const varName = match[1];
                                        const length = parseInt(match[2]);
                                        result += vars[varName].toString().substring(0, length);
                                    }
                                } else if (op.includes('.right(')) {
                                    const match = op.match(/(\w+)\.right\((\d+)\)/);
                                    if (match && vars[match[1]] !== undefined) {
                                        const varName = match[1];
                                        const length = parseInt(match[2]);
                                        const str = vars[varName].toString();
                                        result += str.substring(str.length - length);
                                    }
                                } else if (op.includes('.substring(')) {
                                    const match = op.match(/(\w+)\.substring\((\d+),\s*(\d+)\)/);
                                    if (match && vars[match[1]] !== undefined) {
                                        const varName = match[1];
                                        const start = parseInt(match[2]);
                                        const length = parseInt(match[3]);
                                        result += vars[varName].toString().substring(start, start + length);
                                    }
                                } else if (!isNaN(op)) {
                                    result += op;
                                }
                            });
                            
                            vars[varName] = result;
                        } else if (value.includes('+') || value.includes('-') || value.includes('*') || 
                                  value.includes('/') || value.includes('^') || value.includes(' DIV ') || 
                                  value.includes(' MOD ') || value.includes('(')) {
                            // Arithmetic expression (including parentheses)
                            vars[varName] = evaluateArithmeticExpression(value, vars);
                        } else if (vars[value] !== undefined) {
                            vars[varName] = vars[value];
                        }
                    }
                } else if (line.startsWith('print(')) {
                    // Print statement
                    const content = line.substring(6, line.length - 1);
                    if (content.startsWith('"') && content.endsWith('"')) {
                        output = content.slice(1, -1);
                    } else if (content.includes('.upper')) {
                        const varName = content.split('.')[0];
                        if (vars[varName] !== undefined) {
                            output = vars[varName].toString().toUpperCase();
                        }
                    } else if (content.includes('.lower')) {
                        const varName = content.split('.')[0];
                        if (vars[varName] !== undefined) {
                            output = vars[varName].toString().toLowerCase();
                        }
                    } else if (content.includes('.length')) {
                        const varName = content.split('.')[0];
                        if (vars[varName] !== undefined) {
                            output = vars[varName].toString().length.toString();
                        }
                    } else if (content.includes('.left(')) {
                        const match = content.match(/(\w+)\.left\((\d+)\)/);
                        if (match && vars[match[1]] !== undefined) {
                            const varName = match[1];
                            const length = parseInt(match[2]);
                            output = vars[varName].toString().substring(0, length);
                        }
                    } else if (content.includes('.right(')) {
                        const match = content.match(/(\w+)\.right\((\d+)\)/);
                        if (match && vars[match[1]] !== undefined) {
                            const varName = match[1];
                            const length = parseInt(match[2]);
                            const str = vars[varName].toString();
                            output = str.substring(str.length - length);
                        }
                    } else if (content.includes('.substring(')) {
                        const match = content.match(/(\w+)\.substring\((\d+),\s*(\d+)\)/);
                        if (match && vars[match[1]] !== undefined) {
                            const varName = match[1];
                            const start = parseInt(match[2]);
                            const length = parseInt(match[3]);
                            output = vars[varName].toString().substring(start, start + length);
                        }
                    } else if (content.includes('[') && content.includes(']')) {
                        // Array indexing like nums[i] or country[x]
                        const match = content.match(/(\w+)\[(\w+)\]/);
                        if (match) {
                            const arrayVar = match[1];
                            const indexVar = match[2];
                            if (vars[arrayVar] !== undefined && vars[indexVar] !== undefined) {
                                if (Array.isArray(vars[arrayVar])) {
                                    // Handle actual arrays
                                    const index = parseInt(vars[indexVar]);
                                    if (index >= 0 && index < vars[arrayVar].length) {
                                        output = vars[arrayVar][index].toString();
                                    } else {
                                        output = ''; // Index out of bounds
                                    }
                                } else {
                                    // Handle string indexing (existing functionality)
                                    const arrayValue = vars[arrayVar].toString();
                                    const index = parseInt(vars[indexVar]); // Direct 0-based index
                                    if (index >= 0 && index < arrayValue.length) {
                                        output = arrayValue[index];
                                    } else {
                                        output = ''; // Index out of bounds
                                    }
                                }
                            }
                        }
                    } else if (vars[content] !== undefined) {
                        output = vars[content].toString();
                    } else if (content.includes(',')) {
                        // Handle comma-separated arguments in print
                        const parts = content.split(',').map(p => p.trim());
                        let result = '';
                        parts.forEach((part, index) => {
                            if (index > 0) result += ' '; // Add space between arguments
                            if (part.startsWith('"') && part.endsWith('"')) {
                                result += part.slice(1, -1);
                            } else if (part.includes('.upper')) {
                                const varName = part.split('.')[0];
                                if (vars[varName] !== undefined) {
                                    result += vars[varName].toString().toUpperCase();
                                }
                            } else if (part.includes('.lower')) {
                                const varName = part.split('.')[0];
                                if (vars[varName] !== undefined) {
                                    result += vars[varName].toString().toLowerCase();
                                }
                            } else if (part.includes('.length')) {
                                const varName = part.split('.')[0];
                                if (vars[varName] !== undefined) {
                                    result += vars[varName].toString().length.toString();
                                }
                            } else if (part.includes('.left(')) {
                                const match = part.match(/(\w+)\.left\((\d+)\)/);
                                if (match && vars[match[1]] !== undefined) {
                                    const varName = match[1];
                                    const length = parseInt(match[2]);
                                    result += vars[varName].toString().substring(0, length);
                                }
                            } else if (part.includes('.right(')) {
                                const match = part.match(/(\w+)\.right\((\d+)\)/);
                                if (match && vars[match[1]] !== undefined) {
                                    const varName = match[1];
                                    const length = parseInt(match[2]);
                                    const str = vars[varName].toString();
                                    result += str.substring(str.length - length);
                                }
                            } else if (part.includes('.substring(')) {
                                const match = part.match(/(\w+)\.substring\((\d+),\s*(\d+)\)/);
                                if (match && vars[match[1]] !== undefined) {
                                    const varName = match[1];
                                    const start = parseInt(match[2]);
                                    const length = parseInt(match[3]);
                                    result += vars[varName].toString().substring(start, start + length);
                                }
                            } else if (vars[part] !== undefined) {
                                result += vars[part].toString();
                            } else if (part.startsWith('str(') && part.endsWith(')')) {
                                const varName = part.substring(4, part.length - 1);
                                if (vars[varName] !== undefined) {
                                    result += vars[varName].toString();
                                }
                            }
                        });
                        output = result;
                    } else if (content.includes('+')) {
                        // String concatenation
                        const parts = content.split('+').map(p => p.trim());
                        let result = '';
                        parts.forEach(part => {
                            if (part.startsWith('"') && part.endsWith('"')) {
                                result += part.slice(1, -1);
                            } else if (vars[part] !== undefined) {
                                result += vars[part].toString();
                            } else if (part.startsWith('str(') && part.endsWith(')')) {
                                const varName = part.substring(4, part.length - 1);
                                if (vars[varName] !== undefined) {
                                    result += vars[varName].toString();
                                }
                            }
                        });
                        output = result;
                    } else if (content.includes('*')) {
                        // Arithmetic expression with multiplication
                        const operands = content.split('*').map(op => op.trim());
                        let result = 1;
                        
                        operands.forEach(op => {
                            if (vars[op] !== undefined) {
                                result *= vars[op];
                            } else if (!isNaN(op)) {
                                result *= parseInt(op);
                            }
                        });
                        
                        output = result.toString();
                    } else if (content.includes('-')) {
                        // Arithmetic expression with subtraction
                        const operands = content.split('-').map(op => op.trim());
                        let result = 0;
                        
                        operands.forEach((op, index) => {
                            if (vars[op] !== undefined) {
                                if (index === 0) {
                                    result = vars[op];
                                } else {
                                    result -= vars[op];
                                }
                            } else if (!isNaN(op)) {
                                if (index === 0) {
                                    result = parseInt(op);
                                } else {
                                    result -= parseInt(op);
                                }
                            }
                        });
                        
                        output = result.toString();
                    } else if (content.includes('/')) {
                        // Arithmetic expression with division
                        const operands = content.split('/').map(op => op.trim());
                        let result = 0;
                        
                        operands.forEach((op, index) => {
                            if (vars[op] !== undefined) {
                                if (index === 0) {
                                    result = vars[op];
                                } else {
                                    result = Math.floor(result / vars[op]);
                                }
                            } else if (!isNaN(op)) {
                                if (index === 0) {
                                    result = parseInt(op);
                                } else {
                                    result = Math.floor(result / parseInt(op));
                                }
                            }
                        });
                        
                        output = result.toString();
                    }
                    if (output) outputs.push(output);
                }
                
                return { output, shouldTrace };
            }
            
            let i = 0;
            
            function evaluateCondition(condition, vars) {
                // Simple condition evaluation for basic comparisons
                if (condition.includes('>=')) {
                    const [left, right] = condition.split('>=').map(s => s.trim());
                    let leftVal = vars[left] !== undefined ? vars[left] : left;
                    let rightVal = vars[right] !== undefined ? vars[right] : right;
                    
                    // Handle string methods like .length
                    if (left.includes('.length')) {
                        const varName = left.split('.')[0];
                        if (vars[varName] !== undefined) {
                            leftVal = vars[varName].toString().length;
                        }
                    } else {
                        // Convert to numbers if both values are numeric
                        if (!isNaN(leftVal) && !isNaN(rightVal)) {
                            leftVal = parseFloat(leftVal);
                            rightVal = parseFloat(rightVal);
                        }
                    }
                    
                    return leftVal >= rightVal;
                } else if (condition.includes('<=')) {
                    const [left, right] = condition.split('<=').map(s => s.trim());
                    let leftVal = vars[left] !== undefined ? vars[left] : left;
                    let rightVal = vars[right] !== undefined ? vars[right] : right;
                    
                    // Handle string methods like .length
                    if (left.includes('.length')) {
                        const varName = left.split('.')[0];
                        if (vars[varName] !== undefined) {
                            leftVal = vars[varName].toString().length;
                        }
                    } else {
                        // Convert to numbers if both values are numeric
                        if (!isNaN(leftVal) && !isNaN(rightVal)) {
                            leftVal = parseFloat(leftVal);
                            rightVal = parseFloat(rightVal);
                        }
                    }
                    
                    return leftVal <= rightVal;
                } else if (condition.includes('==')) {
                    const [left, right] = condition.split('==').map(s => s.trim());
                    let leftVal = vars[left] !== undefined ? vars[left] : left;
                    let rightVal = vars[right] !== undefined ? vars[right] : right;
                    
                    // Handle string literals
                    if (leftVal.startsWith && leftVal.startsWith('"') && leftVal.endsWith('"')) {
                        leftVal = leftVal.slice(1, -1);
                    }
                    if (rightVal.startsWith && rightVal.startsWith('"') && rightVal.endsWith('"')) {
                        rightVal = rightVal.slice(1, -1);
                    }
                    
                    return leftVal == rightVal;
                } else if (condition.includes('!=')) {
                    const [left, right] = condition.split('!=').map(s => s.trim());
                    let leftVal = vars[left] !== undefined ? vars[left] : left;
                    let rightVal = vars[right] !== undefined ? vars[right] : right;
                    
                    // Handle string literals
                    if (leftVal.startsWith && leftVal.startsWith('"') && leftVal.endsWith('"')) {
                        leftVal = leftVal.slice(1, -1);
                    }
                    if (rightVal.startsWith && rightVal.startsWith('"') && rightVal.endsWith('"')) {
                        rightVal = rightVal.slice(1, -1);
                    }
                    
                    return leftVal != rightVal;
                } else if (condition.includes('>')) {
                    const [left, right] = condition.split('>').map(s => s.trim());
                    let leftVal = vars[left] !== undefined ? vars[left] : left;
                    let rightVal = vars[right] !== undefined ? vars[right] : right;
                    
                    // Handle string methods like .length
                    if (left.includes('.length')) {
                        const varName = left.split('.')[0];
                        if (vars[varName] !== undefined) {
                            leftVal = vars[varName].toString().length;
                        }
                    } else {
                        // Convert to numbers if both values are numeric
                        if (!isNaN(leftVal) && !isNaN(rightVal)) {
                            leftVal = parseFloat(leftVal);
                            rightVal = parseFloat(rightVal);
                        }
                    }
                    
                    return leftVal > rightVal;
                } else if (condition.includes('<')) {
                    const [left, right] = condition.split('<').map(s => s.trim());
                    let leftVal = vars[left] !== undefined ? vars[left] : left;
                    let rightVal = vars[right] !== undefined ? vars[right] : right;
                    
                    // Handle string methods like .length
                    if (left.includes('.length')) {
                        const varName = left.split('.')[0];
                        if (vars[varName] !== undefined) {
                            leftVal = vars[varName].toString().length;
                        }
                    } else {
                        // Convert to numbers if both values are numeric
                        if (!isNaN(leftVal) && !isNaN(rightVal)) {
                            leftVal = parseFloat(leftVal);
                            rightVal = parseFloat(rightVal);
                        }
                    }
                    
                    return leftVal < rightVal;
                }
                return false;
            }
            
            while (i < lines.length) {
                const line = lines[i];
                const lineNum = i + 1;
                
                if (line.startsWith('if ') && line.includes(' then')) {
                    // If-elseif-else statement
                    const condition = line.substring(3, line.indexOf(' then')).trim();
                    
                    // Find the structure of the if statement
                    let endifIndex = -1;
                    let elseifIndices = [];
                    let elseIndex = -1;
                    let depth = 0;
                    
                    for (let j = i + 1; j < lines.length; j++) {
                        if (lines[j].startsWith('if ')) depth++;
                        if (lines[j] === 'endif') {
                            if (depth === 0) {
                                endifIndex = j;
                                break;
                            }
                            depth--;
                        } else if (lines[j].startsWith('elseif ') && depth === 0) {
                            elseifIndices.push(j);
                        } else if (lines[j] === 'else' && depth === 0) {
                            elseIndex = j;
                        }
                    }
                    
                    // Evaluate conditions and execute the appropriate block
                    let conditionMet = evaluateCondition(condition, variables);
                    let executionStart = i + 1;
                    let executionEnd = elseifIndices.length > 0 ? elseifIndices[0] : 
                                      (elseIndex !== -1 ? elseIndex : endifIndex);
                    
                    if (!conditionMet) {
                        // Check elseif conditions
                        for (let k = 0; k < elseifIndices.length; k++) {
                            const elseifLine = lines[elseifIndices[k]];
                            const elseifCondition = elseifLine.substring(7, elseifLine.indexOf(' then')).trim();
                            
                            if (evaluateCondition(elseifCondition, variables)) {
                                conditionMet = true;
                                executionStart = elseifIndices[k] + 1;
                                executionEnd = k + 1 < elseifIndices.length ? elseifIndices[k + 1] : 
                                              (elseIndex !== -1 ? elseIndex : endifIndex);
                                break;
                            }
                        }
                        
                        // If no conditions met and there's an else
                        if (!conditionMet && elseIndex !== -1) {
                            executionStart = elseIndex + 1;
                            executionEnd = endifIndex;
                            conditionMet = true;
                        }
                    }
                    
                    // Execute the appropriate block (only trace lines that actually execute)
                    if (conditionMet) {
                        for (let bodyLine = executionStart; bodyLine < executionEnd; bodyLine++) {
                            const bodyLineCode = lines[bodyLine];
                            const bodyLineNum = bodyLine + 1;
                            const result = executeStatement(bodyLineCode, bodyLineNum, variables);
                            if (result.shouldTrace) {
                                addTraceEntry(bodyLineNum, variables, result.output);
                            }
                        }
                    }
                    
                    // Skip to after endif
                    i = endifIndex + 1;
                    continue;
                } else if (line.startsWith('while ')) {
                    // While loop
                    const condition = line.substring(6).trim();
                    
                    // Find the matching endwhile statement
                    let endwhileIndex = -1;
                    let depth = 0;
                    for (let j = i + 1; j < lines.length; j++) {
                        if (lines[j].startsWith('while ')) depth++;
                        if (lines[j] === 'endwhile') {
                            if (depth === 0) {
                                endwhileIndex = j;
                                break;
                            }
                            depth--;
                        }
                    }
                    
                    // Execute the while loop (only trace executing statements, not condition evaluations)
                    while (evaluateCondition(condition, variables)) {
                        // Execute loop body
                        for (let bodyLine = i + 1; bodyLine < endwhileIndex; bodyLine++) {
                            const bodyLineCode = lines[bodyLine];
                            const bodyLineNum = bodyLine + 1;
                            const result = executeStatement(bodyLineCode, bodyLineNum, variables);
                            if (result.shouldTrace) {
                                addTraceEntry(bodyLineNum, variables, result.output);
                            }
                        }
                    }
                    
                    // Skip to after endwhile
                    i = endwhileIndex + 1;
                    continue;
                } else if (line === 'do') {
                    // Do-until loop
                    // Find the matching until statement
                    let untilIndex = -1;
                    let depth = 0;
                    for (let j = i + 1; j < lines.length; j++) {
                        if (lines[j] === 'do') depth++;
                        if (lines[j].startsWith('until ')) {
                            if (depth === 0) {
                                untilIndex = j;
                                break;
                            }
                            depth--;
                        }
                    }
                    
                    // Execute the do-until loop (execute body at least once, then check condition)
                    do {
                        // Execute loop body
                        for (let bodyLine = i + 1; bodyLine < untilIndex; bodyLine++) {
                            const bodyLineCode = lines[bodyLine];
                            const bodyLineNum = bodyLine + 1;
                            const result = executeStatement(bodyLineCode, bodyLineNum, variables);
                            if (result.shouldTrace) {
                                addTraceEntry(bodyLineNum, variables, result.output);
                            }
                        }
                        
                        // Get the until condition
                        const untilLine = lines[untilIndex];
                        const condition = untilLine.substring(6).trim(); // Remove "until "
                        
                        // Check if condition is met to exit the loop
                        if (evaluateCondition(condition, variables)) {
                            break;
                        }
                    } while (true);
                    
                    // Skip to after until
                    i = untilIndex + 1;
                    continue;
                } else if (line.startsWith('for ') && line.includes(' to ')) {
                    // For loop
                    const forMatch = line.match(/for\s+(\w+)\s*=\s*(\d+)\s+to\s+(\d+)/);
                    if (forMatch) {
                        const loopVar = forMatch[1];
                        const startVal = parseInt(forMatch[2]);
                        const endVal = parseInt(forMatch[3]);
                        
                        // Find the matching next statement
                        let nextLineIndex = -1;
                        let depth = 0;
                        for (let j = i + 1; j < lines.length; j++) {
                            if (lines[j].startsWith('for ')) depth++;
                            if (lines[j].startsWith('next ')) {
                                if (depth === 0) {
                                    nextLineIndex = j;
                                    break;
                                }
                                depth--;
                            }
                        }
                        
                        // Execute the loop
                        for (let loopVal = startVal; loopVal <= endVal; loopVal++) {
                            // Set the loop variable and trace the for line
                            variables[loopVar] = loopVal;
                            addTraceEntry(lineNum, variables, '');
                            
                            // Execute loop body
                            for (let bodyLine = i + 1; bodyLine < nextLineIndex; bodyLine++) {
                                const bodyLineCode = lines[bodyLine];
                                const bodyLineNum = bodyLine + 1;
                                const result = executeStatement(bodyLineCode, bodyLineNum, variables);
                                if (result.shouldTrace) {
                                    addTraceEntry(bodyLineNum, variables, result.output);
                                }
                            }
                        }
                        
                        // Skip to after the next statement
                        i = nextLineIndex + 1;
                        continue;
                    }
                } else if (line.startsWith('next ') || line === 'endif' || line === 'else' || line.startsWith('elseif ') || line === 'endwhile' || line.startsWith('until ')) {
                    // Skip control flow statements as they're handled by their parent structures
                    i++;
                    continue;
                } else {
                    // Regular statement
                    const result = executeStatement(line, lineNum, variables);
                    if (result.shouldTrace) {
                        addTraceEntry(lineNum, variables, result.output);
                    }
                }
                
                i++;
            }
            
            expectedTrace = trace;
            programVariables = Object.keys(variables);
        }

        function createTraceTable() {
            const table = document.getElementById('traceTable');
            const thead = table.querySelector('thead tr');
            const tbody = table.querySelector('tbody');
            
            // Clear existing content
            thead.innerHTML = '<th>Line Number</th>';
            tbody.innerHTML = '';
            
            // Add variable columns
            programVariables.forEach(varName => {
                const th = document.createElement('th');
                th.textContent = varName;
                thead.appendChild(th);
            });
            
            // Add output column
            const outputTh = document.createElement('th');
            outputTh.textContent = 'Output';
            thead.appendChild(outputTh);
            
            // Create rows (enough for the expected trace + a few extra)
            for (let i = 0; i < expectedTrace.length + 2; i++) {
                const row = document.createElement('tr');
                
                // Line number (student enters this)
                const lineCell = document.createElement('td');
                const lineInput = document.createElement('input');
                lineInput.type = 'text';
                lineInput.placeholder = '';
                lineCell.appendChild(lineInput);
                row.appendChild(lineCell);
                
                // Variable cells
                programVariables.forEach(varName => {
                    const cell = document.createElement('td');
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.placeholder = '';
                    cell.appendChild(input);
                    row.appendChild(cell);
                });
                
                // Output cell
                const outputCell = document.createElement('td');
                const outputInput = document.createElement('input');
                outputInput.type = 'text';
                outputInput.placeholder = '';
                outputCell.appendChild(outputInput);
                row.appendChild(outputCell);
                
                tbody.appendChild(row);
            }
        }

        function markAnswer() {
            if (!currentProgram || expectedTrace.length === 0) {
                alert('Please generate a program first!');
                return;
            }
            
            const tbody = document.getElementById('traceTable').querySelector('tbody');
            const rows = tbody.querySelectorAll('tr');
            
            let correct = 0;
            let total = 0;
            let feedback = [];
            
            // Create a list of user entries in order
            const userEntries = [];
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                const lineInput = cells[0].querySelector('input');
                const userLineNumber = lineInput.value.trim();
                
                if (userLineNumber) {
                    const lineNum = parseInt(userLineNumber);
                    const userEntry = {
                        lineNumber: lineNum,
                        lineInput: lineInput,
                        variables: {},
                        outputInput: cells[cells.length - 1].querySelector('input')
                    };
                    
                    // Store variable inputs
                    programVariables.forEach((varName, varIndex) => {
                        userEntry.variables[varName] = cells[varIndex + 1].querySelector('input');
                    });
                    
                    userEntries.push(userEntry);
                }
            });
            
            // Track variable values throughout execution
            const variableHistory = {};
            programVariables.forEach(varName => {
                variableHistory[varName] = undefined;
            });
            
            // Process expected trace in order, matching with user entries
            let userIndex = 0;
            let currentIteration = 1;
            let lastLoopVar = null;
            
            expectedTrace.forEach((expectedEntry, traceIndex) => {
                const lineNum = expectedEntry.lineNumber;
                
                // Check if we're in a new iteration (loop variable changed)
                const loopVarName = Object.keys(expectedEntry.variables).find(varName => 
                    varName === 'x' || varName === 'i' || varName.length === 1
                );
                if (loopVarName && expectedEntry.variables[loopVarName] !== lastLoopVar) {
                    if (lastLoopVar !== null) {
                        currentIteration++;
                    }
                    lastLoopVar = expectedEntry.variables[loopVarName];
                }
                
                // Find the next user entry that matches this line number
                let userEntry = null;
                if (userIndex < userEntries.length && userEntries[userIndex].lineNumber === lineNum) {
                    userEntry = userEntries[userIndex];
                    userIndex++;
                }
                
                if (userEntry) {
                    // Check line number
                    total++;
                    correct++;
                    userEntry.lineInput.style.backgroundColor = '#c6f6d5';
                    
                    // Check variables
                    programVariables.forEach(varName => {
                        const input = userEntry.variables[varName];
                        const userValue = input.value.trim();
                        const expectedValue = expectedEntry.variables[varName];
                        const previousValue = variableHistory[varName];
                        
                        total++;
                        
                        // Check if the value changed from the previous state
                        const valueChanged = expectedValue !== previousValue;
                        
                        if (valueChanged) {
                            // Value changed, should be filled in
                            if (expectedValue === undefined) {
                                if (userValue === '' || userValue === 'undefined') {
                                    correct++;
                                    input.style.backgroundColor = '#c6f6d5';
                                } else {
                                    input.style.backgroundColor = '#fed7d7';
                                    feedback.push(`Line ${lineNum}, ${varName}: Expected undefined (changed), got "${userValue}"`);
                                }
                            } else {
                                if (userValue == expectedValue.toString()) {
                                    correct++;
                                    input.style.backgroundColor = '#c6f6d5';
                                } else {
                                    input.style.backgroundColor = '#fed7d7';
                                    feedback.push(`Line ${lineNum}, ${varName}: Expected "${expectedValue}" (changed), got "${userValue}"`);
                                }
                            }
                        } else {
                            // Value didn't change, should be empty
                            if (userValue === '') {
                                correct++;
                                input.style.backgroundColor = '#c6f6d5';
                            } else {
                                input.style.backgroundColor = '#fed7d7';
                                feedback.push(`Line ${lineNum}, ${varName}: Value unchanged, should be empty but got "${userValue}"`);
                            }
                        }
                        
                        // Update the variable history
                        variableHistory[varName] = expectedValue;
                    });
                    
                    // Check output
                    const userOutput = userEntry.outputInput.value.trim();
                    const expectedOutput = expectedEntry.output || '';
                    
                    total++;
                    
                    if (userOutput === expectedOutput) {
                        correct++;
                        userEntry.outputInput.style.backgroundColor = '#c6f6d5';
                    } else {
                        userEntry.outputInput.style.backgroundColor = '#fed7d7';
                        if (expectedOutput) {
                            feedback.push(`Line ${lineNum}, Output: Expected "${expectedOutput}", got "${userOutput}"`);
                        } else if (userOutput) {
                            feedback.push(`Line ${lineNum}, Output: Expected no output, got "${userOutput}"`);
                        }
                    }
                } else {
                    // Missing entry
                    feedback.push(`Missing entry for line ${lineNum} (iteration ${currentIteration})`);
                    total += 1 + programVariables.length + 1; // Line number + variables + output
                    // Update variable history even for missing entries
                    programVariables.forEach(varName => {
                        variableHistory[varName] = expectedEntry.variables[varName];
                    });
                }
            });
            
            // Check for extra entries (remaining user entries that weren't matched)
            for (let i = userIndex; i < userEntries.length; i++) {
                const userEntry = userEntries[i];
                total++;
                userEntry.lineInput.style.backgroundColor = '#fed7d7';
                feedback.push(`Line ${userEntry.lineNumber}: Extra entry not expected in the trace`);
                
                // Mark variable cells as incorrect too
                programVariables.forEach(varName => {
                    const input = userEntry.variables[varName];
                    if (input.value.trim()) {
                        total++;
                        input.style.backgroundColor = '#fed7d7';
                    }
                });
                
                // Mark output cell as incorrect if filled
                if (userEntry.outputInput.value.trim()) {
                    total++;
                    userEntry.outputInput.style.backgroundColor = '#fed7d7';
                }
            }
            
            // Display results
            const feedbackDiv = document.getElementById('feedback');
            const scoreDiv = document.getElementById('score');
            const feedbackText = document.getElementById('feedbackText');
            
            const percentage = total > 0 ? Math.round((correct / total) * 100) : 0;
            
            scoreDiv.textContent = `Score: ${correct}/${total} (${percentage}%)`;
            
            if (percentage >= 80) {
                feedbackDiv.className = 'feedback success';
                // Clear any inline styles that might override the CSS class
                feedbackDiv.style.backgroundColor = '';
                feedbackDiv.style.color = '';
                feedbackDiv.style.borderColor = '';
                feedbackText.textContent = 'Excellent work! ' + (feedback.length > 0 ? 'Minor corrections needed:' : 'Perfect!');
            } else if (percentage >= 60) {
                feedbackDiv.className = 'feedback';
                feedbackDiv.style.backgroundColor = '#fef5e7';
                feedbackDiv.style.color = '#d69e2e';
                feedbackDiv.style.borderColor = '#f6e05e';
                feedbackText.textContent = 'Good effort! Some corrections needed:';
            } else {
                feedbackDiv.className = 'feedback error';
                // Clear any inline styles that might override the CSS class
                feedbackDiv.style.backgroundColor = '';
                feedbackDiv.style.color = '';
                feedbackDiv.style.borderColor = '';
                feedbackText.textContent = 'Keep practicing! Corrections needed:';
            }
            
            if (feedback.length > 0) {
                feedbackText.innerHTML += '<br><br>' + feedback.join('<br>');
            }
            
            feedbackDiv.style.display = 'block';
        }

        function clearTable() {
            const tbody = document.getElementById('traceTable').querySelector('tbody');
            const rows = tbody.querySelectorAll('tr');
            
            // Clear all input values and reset background colors
            rows.forEach(row => {
                const inputs = row.querySelectorAll('input');
                inputs.forEach(input => {
                    input.value = '';
                    input.style.backgroundColor = '';
                });
            });
            
            // Hide feedback
            document.getElementById('feedback').style.display = 'none';
        }

        function toggleProgramSelector() {
            const mode = document.getElementById('mode').value;
            const programSelector = document.getElementById('programSelector');
            const generateButton = document.querySelector('.btn-primary');
            
            if (mode === 'select') {
                programSelector.style.display = 'flex';
                generateButton.textContent = '📋 Load Selected Program';
                updateProgramSelector();
            } else {
                programSelector.style.display = 'none';
                generateButton.textContent = '🔄 Generate New Program';
            }
        }

        function updateProgramSelector() {
            const difficulty = document.getElementById('difficulty').value;
            const programChoice = document.getElementById('programChoice');
            const programList = programs[difficulty];
            
            // Clear existing options
            programChoice.innerHTML = '';
            
            // Add programs for the selected difficulty
            programList.forEach((program, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = program.description;
                programChoice.appendChild(option);
            });
        }

        // Initialize with a program
        updateProgramSelector(); // Initialize the program selector with easy programs
        generateProgram();
    </script>
</body>
</html>