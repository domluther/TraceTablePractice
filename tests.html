<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trace Table Practice - Unit Tests</title>
    <link rel="stylesheet" href="css/test-styles.css">
</head>
<body>
    <div class="container">
        <h1>ğŸ§ª Trace Table Practice - Unit Tests</h1>
        
        <div id="testSummary"></div>
        
        <button class="run-tests-btn" onclick="runAllTests()">ğŸ”„ Run All Tests</button>
        <button class="toggle-btn" id="togglePassedBtn" onclick="togglePassedTests()" title="Toggle passed tests visibility (Shortcut: H key)">ğŸ‘ï¸ Show Passed Tests</button>
        
        <div id="testResults"></div>
    </div>

    <script type="module">
        // ============================================================================
        // UNIT TESTS - SCOPE AND PURPOSE
        // ============================================================================
        /*
         * These unit tests focus on testing individual interpreter methods and
         * language features in isolation. They verify that each component works
         * correctly on its own, without testing complete program flows.
         * 
         * UNIT TEST SCOPE:
         * - Individual arithmetic operations and operator precedence
         * - String methods (.upper, .lower, .left, .substring, etc.)
         * - Array access and indexing
         * - Type conversions (float, int, bool)
         * - Basic control structures (for loops, switch/case)
         * - Language features (comments, constants)
         * - Edge cases and error conditions
         * - Expression evaluation and parsing
         * 
         * DESIGN PRINCIPLES:
         * - Each test function focuses on one specific feature or capability
         * - Tests are independent and can run in any order
         * - Clear naming conventions make test purpose obvious
         * - Comprehensive coverage without redundancy
         * - Maintainable structure with clear section organization
         * 
         * For comprehensive program testing, see integration-tests.html
         */
        
        // ============================================================================
        // TEST FRAMEWORK AND UTILITIES
        // ============================================================================
        
        // Import the actual production Interpreter class
        import { Interpreter } from './js/interpreter.js';
        
        // Test state management
        let testResults = [];
        let testsPassed = 0;
        let testsFailed = 0;
        
        /**
         * Core assertion function for unit testing
         * @param {boolean} condition - The condition to test
         * @param {string} testName - Descriptive name of the test
         * @param {string} details - Additional diagnostic information
         */
        function assert(condition, testName, details = '') {
            if (condition) {
                testResults.push({
                    name: testName,
                    passed: true,
                    details: details
                });
                testsPassed++;
            } else {
                testResults.push({
                    name: testName,
                    passed: false,
                    details: details
                });
                testsFailed++;
            }
        }
        
        /**
         * Equality assertion with detailed failure reporting
         * @param {any} actual - The actual value produced
         * @param {any} expected - The expected value
         * @param {string} testName - Descriptive name of the test
         * @param {string} details - Additional context
         */
        function assertEqual(actual, expected, testName, details = '') {
            const condition = actual === expected;
            const testDetails = details + ` (Expected: ${expected}, Got: ${actual})`;
            assert(condition, testName, testDetails);
        }
        
        /**
         * Array equality assertion for comprehensive comparisons
         * @param {Array} actual - The actual array produced
         * @param {Array} expected - The expected array
         * @param {string} testName - Descriptive name of the test
         * @param {string} details - Additional context
         */
        function assertArrayEqual(actual, expected, testName, details = '') {
            const condition = JSON.stringify(actual) === JSON.stringify(expected);
            const testDetails = details + ` (Expected: ${JSON.stringify(expected)}, Got: ${JSON.stringify(actual)})`;
            assert(condition, testName, testDetails);
        }
        
        // ============================================================================
        // BASIC ARITHMETIC OPERATIONS TESTS
        // ============================================================================
        
        /**
         * Test basic arithmetic operations
         * Covers: addition, subtraction, multiplication, division, modulo, exponentiation
         */
        function testBasicArithmetic() {
            const interpreter = new Interpreter();
            const vars = { a: 5, b: 3, c: 2 };
            
            // Test basic operations
            assertEqual(interpreter.evaluateArithmeticExpression('a + b', vars), 8, 'Basic Addition (5 + 3 = 8)');
            assertEqual(interpreter.evaluateArithmeticExpression('a - b', vars), 2, 'Basic Subtraction (5 - 3 = 2)');
            assertEqual(interpreter.evaluateArithmeticExpression('a * b', vars), 15, 'Basic Multiplication (5 * 3 = 15)');
            assertEqual(interpreter.evaluateArithmeticExpression('a / c', vars), 2.5, 'Basic Division (5 / 2 = 2.5)');
            assertEqual(interpreter.evaluateArithmeticExpression('a MOD b', vars), 2, 'Basic Modulo (5 MOD 3 = 2)');
            assertEqual(interpreter.evaluateArithmeticExpression('a DIV b', vars), 1, 'Basic Integer Division (5 DIV 3 = 1)');
            assertEqual(interpreter.evaluateArithmeticExpression('b ^ c', vars), 9, 'Basic Exponentiation (3 ^ 2 = 9)');
        }
        
        /**
         * Test operator precedence rules
         * Covers: order of operations, left-to-right evaluation
         */
        function testOperatorPrecedence() {
            const interpreter = new Interpreter();
            const vars = { a: 2, b: 3, c: 4 };
            
            // Test precedence rules
            assertEqual(interpreter.evaluateArithmeticExpression('a + b * c', vars), 14, 'Multiplication before Addition (2 + 3 * 4 = 14)');
            assertEqual(interpreter.evaluateArithmeticExpression('c / a - b', vars), -1, 'Division before Subtraction (4 / 2 - 3 = -1)');
            assertEqual(interpreter.evaluateArithmeticExpression('a * b ^ a', vars), 18, 'Exponentiation before Multiplication (2 * 3 ^ 2 = 18)');
            assertEqual(interpreter.evaluateArithmeticExpression('a + b - c', vars), 1, 'Left-to-right for Addition/Subtraction (2 + 3 - 4 = 1)');
            assertEqual(interpreter.evaluateArithmeticExpression('a * b / a', vars), 3, 'Left-to-right for Multiplication/Division (2 * 3 / 2 = 3)');
        }
        
        /**
         * Test parentheses in expressions
         * Covers: grouping, nested parentheses, complex expressions
         */
        function testParentheses() {
            const interpreter = new Interpreter();
            const vars = { a: 2, b: 3, c: 4 };
            
            // Test parentheses
            assertEqual(interpreter.evaluateArithmeticExpression('(a + b) * c', vars), 20, 'Basic Parentheses ((2 + 3) * 4 = 20)');
            assertEqual(interpreter.evaluateArithmeticExpression('((a + b) * c) / (a + c)', vars), 20/6, 'Nested Parentheses (((2 + 3) * 4) / (2 + 4) = 20/6)');
            
            // Rectangle perimeter calculation
            const rectVars = { length: 5, width: 3 };
            assertEqual(interpreter.evaluateArithmeticExpression('2 * (length + width)', rectVars), 16, 'Rectangle Perimeter (2 * (5 + 3) = 16)');
            assertEqual(interpreter.evaluateArithmeticExpression('(a + b) * (c - a)', vars), 10, 'Complex Parentheses ((2 + 3) * (4 - 2) = 10)');
        }
        
        /**
         * Test array access operations
         * Covers: variable indices, literal indices, arithmetic with arrays
         */
        function testArrayAccess() {
            const interpreter = new Interpreter();
            const vars = { 
                nums: [10, 20, 30], 
                i: 1,
                j: 0
            };
            
            // Test array access
            assertEqual(interpreter.getExpressionValue('nums[i]', vars), 20, 'Array Access with Variable Index (nums[1] = 20)');
            assertEqual(interpreter.getExpressionValue('nums[0]', vars), 10, 'Array Access with Literal Index (nums[0] = 10)');
            assertEqual(interpreter.evaluateArithmeticExpression('nums[i] + nums[j]', vars), 30, 'Arithmetic with Array Access (nums[1] + nums[0] = 30)');
            assertEqual(interpreter.evaluateArithmeticExpression('nums[i] * 2', vars), 40, 'Array Access in Multiplication (nums[1] * 2 = 40)');
        }
        
        /**
         * Test string method operations
         * Covers: .upper, .lower, .left, string concatenation
         */
        function testStringMethods() {
            const interpreter = new Interpreter();
            const vars = {
                first_name: 'John',
                last_name: 'Smith',
                count: 4
            };
            
            // Test string methods
            const firstInitial = interpreter.evaluateStringConcatenation('first_name.left(1)', vars);
            assertEqual(firstInitial, 'J', 'First name .left(1) should return "J"');
            
            const lastInitial = interpreter.evaluateStringConcatenation('last_name.left(1)', vars);
            assertEqual(lastInitial, 'S', 'Last name .left(1) should return "S"');
            
            const initials = interpreter.evaluateStringConcatenation('first_name.left(1) + last_name.left(1)', vars);
            assertEqual(initials, 'JS', 'Initials concatenation should return "JS"');
            
            assertEqual(interpreter.evaluateStringConcatenation('first_name.upper', vars), 'JOHN', 'String .upper method');
            assertEqual(interpreter.evaluateStringConcatenation('first_name.lower', vars), 'john', 'String .lower method');
        }
        
        /**
         * Test for loop execution
         * Covers: loop variables, trace entries, output generation
         */
        function testForLoopExecution() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: [], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                for x = 0 to 2
                    print(x*2)
                next x
            `, testProgram);
            
            // Check variables and outputs
            assertEqual(testInterpreter.variables.x, 2, 'x should be 2 after loop completion');
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], '0', 'First output should be "0"');
            assertEqual(testInterpreter.outputs[1], '2', 'Second output should be "2"');
            assertEqual(testInterpreter.outputs[2], '4', 'Third output should be "4"');
        }
        
        /**
         * Test variable operations and expressions
         * Covers: variable access, numeric literals, expression evaluation
         */
        function testVariableOperations() {
            const interpreter = new Interpreter();
            const vars = { 
                x: 10, 
                y: 0,
                temp: 5
            };
            
            // Test variable access
            assertEqual(interpreter.getExpressionValue('x', vars), 10, 'Variable Access (x = 10)');
            assertEqual(interpreter.getExpressionValue('temp', vars), 5, 'Variable Access (temp = 5)');
            
            // Test numeric literals
            assertEqual(interpreter.getExpressionValue('42', vars), 42, 'Numeric Literal (42)');
            assertEqual(interpreter.getExpressionValue('0', vars), 0, 'Numeric Literal (0)');
        }
        
        /**
         * Test complex expressions
         * Covers: multi-operator expressions, nested operations
         */
        function testComplexExpressions() {
            const interpreter = new Interpreter();
            const vars = { 
                a: 2, 
                b: 3, 
                c: 4,
                nums: [1, 2, 3, 4, 5],
                index: 2
            };
            
            // Test complex arithmetic expression
            assertEqual(interpreter.evaluateArithmeticExpression('a * b + c * (a + b) - nums[index]', vars), 23, 
                'Complex Expression (2 * 3 + 4 * (2 + 3) - 3 = 23)');
            
            // Test expression with multiple operators
            assertEqual(interpreter.evaluateArithmeticExpression('a ^ b + c / a * nums[0]', vars), 10, 
                'Multiple Operators (2 ^ 3 + 4 / 2 * 1 = 10)');
        }
        
        /**
         * Test edge cases and boundary conditions
         * Covers: division by one, multiplication by zero, array bounds
         */
        function testEdgeCases() {
            const interpreter = new Interpreter();
            const vars = { 
                zero: 0, 
                one: 1, 
                ten: 10,
                emptyArray: [],
                smallArray: [42]
            };
            
            // Test edge operations
            assertEqual(interpreter.evaluateArithmeticExpression('ten / one', vars), 10, 'Division by One (10 / 1 = 10)');
            assertEqual(interpreter.evaluateArithmeticExpression('ten * zero', vars), 0, 'Multiplication by Zero (10 * 0 = 0)');
            assertEqual(interpreter.evaluateArithmeticExpression('ten ^ zero', vars), 1, 'Power of Zero (10 ^ 0 = 1)');
            
            // Test array bounds (should return 0 for out of bounds)
            assertEqual(interpreter.getExpressionValue('emptyArray[0]', vars), 0, 'Empty Array Access (should return 0)');
            assertEqual(interpreter.getExpressionValue('smallArray[5]', vars), 0, 'Out of Bounds Array Access (should return 0)');
        }
        
        /**
         * Test type conversions
         * Covers: float(), int(), bool() type casting with various input types
         */
        function testTypeConversions() {
            const testInterpreter = new Interpreter();
            
            // Test float conversion with program inputs
            const floatProgram = { inputs: ["3.14", "2.5"], randomValue: undefined };
            const floatResult = testInterpreter.executeProgram(`
                x = float(input("Enter number"))
                numValue = 7.89
                y = float(numValue)
                print(x)
                print(y)
            `, floatProgram);
            
            assertEqual(testInterpreter.variables.x, 3.14, 'float(input()) should convert "3.14" to 3.14');
            assertEqual(testInterpreter.variables.y, 7.89, 'float(numValue) should convert variable to 7.89');
            
            // Reset interpreter for int tests
            const intInterpreter = new Interpreter();
            const intCode = `numValue = 42
x = int(numValue)
floatValue = 3.14
y = int(floatValue)
z = int(0)`;
            
            intInterpreter.execute(intCode);
            
            assertEqual(intInterpreter.variables.x, 42, 'int(numValue) should convert variable to 42');
            assertEqual(intInterpreter.variables.y, 3, 'int(3.14) should convert variable to 3');
            assertEqual(intInterpreter.variables.z, 0, 'int(0) should convert variable to 0');
            
            // Reset interpreter for bool tests
            const boolInterpreter = new Interpreter();
            const boolCode = `isTrue = bool("True")
isFalse = bool("False")
zeroNum = 0
isZero = bool(zeroNum)
oneNum = 1
isOne = bool(oneNum)
emptyStr = ""
isEmpty = bool(emptyStr)
textStr = "hello"
isText = bool(textStr)`;
            
            boolInterpreter.execute(boolCode);
            
            assertEqual(boolInterpreter.variables.isTrue, true, 'bool("True") should be true');
            assertEqual(boolInterpreter.variables.isFalse, false, 'bool("False") should be false');
            assertEqual(boolInterpreter.variables.isZero, false, 'bool(0) should be false');
            assertEqual(boolInterpreter.variables.isOne, true, 'bool(1) should be true');
            assertEqual(boolInterpreter.variables.isEmpty, false, 'bool("") should be false for empty string');
            assertEqual(boolInterpreter.variables.isText, false, 'bool("hello") should be false for non-empty non-True string');
        }
        
        /**
         * Test nested conditional execution with comprehensive scenarios
         * Covers: nested if/then/else logic, MOD operator in conditions, if statements inside loops, 
         *         switch statements inside loops, multi-level nesting, conditional logic inside while loops
         */
        function testNestedConditionalExecution() {
            // Test 1: Basic nested if with both conditions true (jump qualification scenario)
            const testInterpreter1 = new Interpreter();
            const testProgram1 = { inputs: ["3.5", "12"], randomValue: undefined };
            
            testInterpreter1.executeProgram(`
                jumpLength = float(input("Enter jump length"))
                yearGroup = float(input("Enter year group"))
                if jumpLength > 2 then
                    if yearGroup >= 10 then
                        result = "qualify"
                    else
                        result = "too young"
                    endif
                else
                    result = "not long enough"
                endif
            `, testProgram1);
            
            assertEqual(testInterpreter1.variables.jumpLength, 3.5, 'Nested If - Both True: jumpLength should be 3.5');
            assertEqual(testInterpreter1.variables.yearGroup, 12, 'Nested If - Both True: yearGroup should be 12');
            assertEqual(testInterpreter1.variables.result, "qualify", 'Nested If - Both True: Should execute inner if branch when both conditions true');
            
            // Test 2: Nested if with outer true, inner false (age restriction scenario)
            const testInterpreter2 = new Interpreter();
            const testProgram2 = { inputs: ["2.5", "8"], randomValue: undefined };
            
            testInterpreter2.executeProgram(`
                jumpLength = float(input("Enter jump length"))
                yearGroup = float(input("Enter year group"))
                if jumpLength > 2 then
                    if yearGroup >= 10 then
                        result = "qualify"
                    else
                        result = "too young"
                    endif
                else
                    result = "not long enough"
                endif
            `, testProgram2);
            
            assertEqual(testInterpreter2.variables.jumpLength, 2.5, 'Nested If - Outer True Inner False: jumpLength should be 2.5');
            assertEqual(testInterpreter2.variables.yearGroup, 8, 'Nested If - Outer True Inner False: yearGroup should be 8');
            assertEqual(testInterpreter2.variables.result, "too young", 'Nested If - Outer True Inner False: Should execute inner else branch');
            
            // Test 3: Nested if with outer false (distance failure scenario)
            const testInterpreter3 = new Interpreter();
            const testProgram3 = { inputs: ["1.5", "12"], randomValue: undefined };
            
            testInterpreter3.executeProgram(`
                jumpLength = float(input("Enter jump length"))
                yearGroup = float(input("Enter year group"))
                if jumpLength > 2 then
                    if yearGroup >= 10 then
                        result = "qualify"
                    else
                        result = "too young"
                    endif
                else
                    result = "not long enough"
                endif
            `, testProgram3);
            
            assertEqual(testInterpreter3.variables.jumpLength, 1.5, 'Nested If - Outer False: jumpLength should be 1.5');
            assertEqual(testInterpreter3.variables.yearGroup, 12, 'Nested If - Outer False: yearGroup should be 12');
            assertEqual(testInterpreter3.variables.result, "not long enough", 'Nested If - Outer False: Should execute outer else branch when outer condition false');
            
            // Test 4: MOD operator in conditions within for loop (even/odd number detection)
            const testInterpreter4 = new Interpreter();
            const testProgram4 = { inputs: [], randomValue: undefined };
            
            testInterpreter4.executeProgram(`
                total = 0
                for i = 1 to 5
                    if i MOD 2 == 0 then
                        total = total + i
                        print("even: " + i)
                    else
                        print("odd: " + i)
                    endif
                next i
            `, testProgram4);
            
            assertEqual(testInterpreter4.variables.total, 6, 'MOD in For Loop: total should be 6 (2 + 4)');
            assertEqual(testInterpreter4.outputs.length, 5, 'MOD in For Loop: Should have 5 outputs from loop');
            assertEqual(testInterpreter4.outputs[0], 'odd: 1', 'MOD in For Loop: First output should be "odd: 1"');
            assertEqual(testInterpreter4.outputs[1], 'even: 2', 'MOD in For Loop: Second output should be "even: 2"');
            assertEqual(testInterpreter4.outputs[4], 'odd: 5', 'MOD in For Loop: Fifth output should be "odd: 5"');
            
            // Test 5: Switch statements inside for loop (day name mapping)
            const testInterpreter5 = new Interpreter();
            const testProgram5 = { inputs: [], randomValue: undefined };
            
            testInterpreter5.executeProgram(`
                for day = 1 to 3
                    switch day:
                    case 1:
                        print("Monday")
                    case 2:
                        print("Tuesday")
                    case 3:
                        print("Wednesday")
                    default:
                        print("Unknown")
                    endswitch
                next day
            `, testProgram5);
            
            assertEqual(testInterpreter5.variables.day, 3, 'Switch in For Loop: day should be 3 after loop completion');
            assertEqual(testInterpreter5.outputs.length, 3, 'Switch in For Loop: Should have 3 outputs from switch in loop');
            assertEqual(testInterpreter5.outputs[0], 'Monday', 'Switch in For Loop: First output should be "Monday"');
            assertEqual(testInterpreter5.outputs[1], 'Tuesday', 'Switch in For Loop: Second output should be "Tuesday"');
            assertEqual(testInterpreter5.outputs[2], 'Wednesday', 'Switch in For Loop: Third output should be "Wednesday"');
            
            // Test 6: Triple-nested if statements (grade evaluation with score and letter grade)
            const testInterpreter6 = new Interpreter();
            const testProgram6 = { inputs: ["85", "A"], randomValue: undefined };
            
            testInterpreter6.executeProgram(`
                score = float(input("Enter score"))
                grade = input("Enter grade")
                if score >= 80 then
                    if grade == "A" then
                        if score >= 90 then
                            result = "excellent"
                        else
                            result = "good"
                        endif
                    else
                        result = "needs improvement"
                    endif
                else
                    result = "failing"
                endif
            `, testProgram6);
            
            assertEqual(testInterpreter6.variables.score, 85, 'Triple Nested If: score should be 85');
            assertEqual(testInterpreter6.variables.grade, "A", 'Triple Nested If: grade should be "A"');
            assertEqual(testInterpreter6.variables.result, "good", 'Triple Nested If: Should execute middle nested branch (score >= 80, grade A, but score < 90)');
            
            // Test 7: If statements inside while loop (conditional execution during iteration)
            const testInterpreter7 = new Interpreter();
            const testProgram7 = { inputs: [], randomValue: undefined };
            
            testInterpreter7.executeProgram(`
                count = 0
                x = 1
                while x <= 4
                    if x == 2 then
                        print("found two")
                    endif
                    if x > 3 then
                        print("greater than three")
                    endif
                    count = count + 1
                    x = x + 1
                endwhile
            `, testProgram7);
            
            assertEqual(testInterpreter7.variables.count, 4, 'If in While Loop: count should be 4');
            assertEqual(testInterpreter7.variables.x, 5, 'If in While Loop: x should be 5 after loop');
            assertEqual(testInterpreter7.outputs.length, 2, 'If in While Loop: Should have 2 conditional outputs');
            assertEqual(testInterpreter7.outputs[0], 'found two', 'If in While Loop: Should find "found two" when x=2');
            assertEqual(testInterpreter7.outputs[1], 'greater than three', 'If in While Loop: Should find "greater than three" when x=4');
        }
        
        /**
         * Test string methods in print statements and output generation
         * Covers: .upper/.lower case conversion in output, .length property in output, 
         *         string method chaining with print statements
         */
        function testStringMethodsInPrint() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: ["hello", "WORLD"], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                name = input("Enter name")
                city = input("Enter city")
                print(name.upper)
                print(city.lower)
                print(name.length)
            `, testProgram);
            
            // Check variables and outputs
            assertEqual(testInterpreter.variables.name, 'hello', 'String Methods in Print: name should be "hello"');
            assertEqual(testInterpreter.variables.city, 'WORLD', 'String Methods in Print: city should be "WORLD"');
            assertEqual(testInterpreter.outputs.length, 3, 'String Methods in Print: Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], 'HELLO', 'String Methods in Print: .upper conversion should output "HELLO"');
            assertEqual(testInterpreter.outputs[1], 'world', 'String Methods in Print: .lower conversion should output "world"');
            assertEqual(testInterpreter.outputs[2], '5', 'String Methods in Print: .length property should output "5"');
        }
        
        /**
         * Test substring method with dynamic loop variables
         * Covers: substring extraction with variable position parameters, 
         *         string method execution inside loops, character-by-character extraction
         */
        function testSubstringWithVariable() {
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: [], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                for x = 1 to 3
                    country = "France"
                    print(country.substring(x, 1))
                next x
            `, testProgram);
            
            // Check outputs - should extract characters at positions 1, 2, 3 (r, a, n)
            assertEqual(testInterpreter.variables.x, 3, 'Substring with Variable: x should be 3 after loop completion');
            assertEqual(testInterpreter.outputs.length, 3, 'Substring with Variable: Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], 'r', 'Substring with Variable: Position 1 extraction should be "r"');
            assertEqual(testInterpreter.outputs[1], 'a', 'Substring with Variable: Position 2 extraction should be "a"');
            assertEqual(testInterpreter.outputs[2], 'n', 'Substring with Variable: Position 3 extraction should be "n"');
        }
        
        /**
         * Test comment handling
         * Covers: comments ignored in execution, proper line tracing
         */
        function testComments() {
            const testInterpreter = new Interpreter();
            
            const codeWithComments = `// This is a comment
x = 5
// Another comment here
y = 10
// Final comment
z = x + y`;
            
            const result = testInterpreter.execute(codeWithComments);
            
            // Verify that only assignment lines are traced, comments are ignored
            assertEqual(testInterpreter.variables.x, 5, 'x should be 5 despite comments');
            assertEqual(testInterpreter.variables.y, 10, 'y should be 10 despite comments');
            assertEqual(testInterpreter.variables.z, 15, 'z should be 15 (x + y)');
            assertEqual(testInterpreter.trace.length, 3, 'Should have exactly 3 trace entries (no comments traced)');
        }
        
        /**
         * Test constant declarations
         * Covers: const keyword, constant protection
         */
        function testConstants() {
            const testInterpreter = new Interpreter();
            
            const constCode = `const pi = 3.14159
const vat = 0.2
price = 100
total = price * (1 + vat)`;
            
            const result = testInterpreter.execute(constCode);
            
            assertEqual(testInterpreter.variables.pi, 3.14159, 'const pi should be 3.14159');
            assertEqual(testInterpreter.variables.vat, 0.2, 'const vat should be 0.2');
            assertEqual(testInterpreter.variables.total, 120, 'total should be 120 (100 * 1.2)');
        }
        
        /**
         * Test for loops with positive step values (counting up)
         * Covers: step parameter parsing, range iteration with custom increments, 
         *         even number generation, step-based loop termination
         */
        function testForLoopWithPositiveStep() {
            const testInterpreter = new Interpreter();
            
            const positiveStepCode = `for i = 2 to 10 step 2
    print(i)
next i`;
            
            const result = testInterpreter.execute(positiveStepCode);
            
            // Should print even numbers: 2, 4, 6, 8, 10
            assertEqual(testInterpreter.outputs.length, 5, 'Positive Step For Loop: Should have 5 outputs for step 2');
            assertEqual(testInterpreter.outputs[0], '2', 'Positive Step For Loop: First even number should be "2"');
            assertEqual(testInterpreter.outputs[1], '4', 'Positive Step For Loop: Second even number should be "4"');
            assertEqual(testInterpreter.outputs[4], '10', 'Positive Step For Loop: Final even number should be "10"');
        }
        
        /**
         * Test for loops with negative step values (counting down)
         * Covers: negative step parameter, countdown iteration, reverse range processing,
         *         negative step termination conditions
         */
        function testForLoopWithNegativeStep() {
            const testInterpreter = new Interpreter();
            
            const negativeStepCode = `for i = 10 to 0 step -1
    print(i)
next i`;
            
            const result = testInterpreter.execute(negativeStepCode);
            
            // Should print countdown: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
            assertEqual(testInterpreter.outputs.length, 11, 'Negative Step For Loop: Should have 11 outputs for countdown');
            assertEqual(testInterpreter.outputs[0], '10', 'Negative Step For Loop: Countdown should start with "10"');
            assertEqual(testInterpreter.outputs[10], '0', 'Negative Step For Loop: Countdown should end with "0"');
        }
        
        /**
         * Test switch/case statements
         * Covers: switch logic, case matching, default cases
         */
        function testSwitchCase() {
            const testInterpreter = new Interpreter();
            
            const basicSwitchCode = `day = "Mon"
switch day:
case "Mon":
    print("Monday")
case "Tue":
    print("Tuesday")
default:
    print("Unknown day")
endswitch
print("Done")`;
            
            const result = testInterpreter.execute(basicSwitchCode);
            
            assertEqual(testInterpreter.variables.day, 'Mon', 'day should be "Mon"');
            assertEqual(testInterpreter.outputs.length, 2, 'Should have exactly 2 outputs');
            assertEqual(testInterpreter.outputs[0], 'Monday', 'First output should be "Monday"');
            assertEqual(testInterpreter.outputs[1], 'Done', 'Second output should be "Done"');
        }
        
        // TEST MANAGEMENT AND EXECUTION
        // ============================================================================
        
        /**
         * Reset test state for a fresh test run
         */
        function resetTestState() {
            testResults = [];
            testsPassed = 0;
            testsFailed = 0;
        }
        
        /**
         * Display comprehensive test summary
         */
        function displayTestSummary() {
            const summaryDiv = document.getElementById('testSummary');
            const passRate = testsPassed + testsFailed > 0 ? 
                Math.round((testsPassed / (testsPassed + testsFailed)) * 100) : 0;
            
            summaryDiv.innerHTML = `
                <div class="test-summary ${passRate === 100 ? 'all-pass' : 'has-failures'}">
                    <h2>ğŸ“Š Unit Test Results</h2>
                    <p><strong>Passed:</strong> ${testsPassed} | <strong>Failed:</strong> ${testsFailed} | <strong>Pass Rate:</strong> ${passRate}%</p>
                    <p><em>Testing individual interpreter methods and language features</em></p>
                </div>
            `;
        }
        
        /**
         * Display categorized test results
         */
        function displayTestResults() {
            const resultsDiv = document.getElementById('testResults');
            
            // Group tests by category
            const testCategories = {
                'Basic Arithmetic': ['Basic Addition', 'Basic Subtraction', 'Basic Multiplication', 'Basic Division', 'Basic Modulo', 'Basic Integer Division', 'Basic Exponentiation'],
                'Operator Precedence': ['Multiplication before Addition', 'Division before Subtraction', 'Exponentiation before Multiplication', 'Left-to-right'],
                'Parentheses': ['Basic Parentheses', 'Nested Parentheses', 'Rectangle Perimeter', 'Complex Parentheses'],
                'Array Access': ['Array Access with Variable Index', 'Array Access with Literal Index', 'Arithmetic with Array Access', 'Array Access in Multiplication'],
                'String Methods': ['First name .left(1)', 'Last name .left(1)', 'Initials concatenation', 'String .upper method', 'String .lower method'],
                'For Loop Execution': ['x should be 2', 'Should have exactly 3 outputs', 'First output should be "0"', 'Second output should be "2"', 'Third output should be "4"'],
                'Variable Operations': ['Variable Access', 'Numeric Literal'],
                'Complex Expressions': ['Complex Expression', 'Multiple Operators'],
                'Edge Cases': ['Division by One', 'Multiplication by Zero', 'Power of Zero', 'Empty Array Access', 'Out of Bounds Array Access'],
                'Type Conversions': ['float(input())', 'float(numValue)', 'int(numValue)', 'int(3.14)', 'int(0)', 'bool("True")', 'bool("False")', 'bool(0)', 'bool(1)', 'bool("")', 'bool("hello")'],
                'Nested Conditionals': [
                    'Nested If - Both True: jumpLength should be 3.5', 'Nested If - Both True: yearGroup should be 12', 'Nested If - Both True: Should execute inner if branch when both conditions true',
                    'Nested If - Outer True Inner False: jumpLength should be 2.5', 'Nested If - Outer True Inner False: yearGroup should be 8', 'Nested If - Outer True Inner False: Should execute inner else branch',
                    'Nested If - Outer False: jumpLength should be 1.5', 'Nested If - Outer False: Should execute outer else branch when outer condition false',
                    'MOD in For Loop: total should be 6', 'MOD in For Loop: Should have 5 outputs from loop', 'MOD in For Loop: First output should be "odd: 1"', 'MOD in For Loop: Second output should be "even: 2"', 'MOD in For Loop: Fifth output should be "odd: 5"',
                    'Switch in For Loop: day should be 3 after loop completion', 'Switch in For Loop: Should have 3 outputs from switch in loop', 'Switch in For Loop: First output should be "Monday"', 'Switch in For Loop: Second output should be "Tuesday"', 'Switch in For Loop: Third output should be "Wednesday"',
                    'Triple Nested If: score should be 85', 'Triple Nested If: grade should be "A"', 'Triple Nested If: Should execute middle nested branch',
                    'If in While Loop: count should be 4', 'If in While Loop: x should be 5 after loop', 'If in While Loop: Should have 2 conditional outputs', 'If in While Loop: Should find "found two"', 'If in While Loop: Should find "greater than three"'
                ],
                'String Methods in Print': ['String Methods in Print: name should be "hello"', 'String Methods in Print: city should be "WORLD"', 'String Methods in Print: Should have exactly 3 outputs', 'String Methods in Print: .upper conversion should output "HELLO"', 'String Methods in Print: .lower conversion should output "world"', 'String Methods in Print: .length property should output "5"'],
                'Substring with Variable': ['Substring with Variable: x should be 3 after loop completion', 'Substring with Variable: Should have exactly 3 outputs', 'Substring with Variable: Position 1 extraction should be "r"', 'Substring with Variable: Position 2 extraction should be "a"', 'Substring with Variable: Position 3 extraction should be "n"'],
                'Comments': ['x should be 5 despite comments', 'y should be 10 despite comments', 'z should be 15 (x + y)', 'Should have exactly 3 trace entries'],
                'Constants': ['const pi should be 3.14159', 'const vat should be 0.2', 'total should be 120 (100 * 1.2)'],
                'For Loops with Positive Step': ['Positive Step For Loop: Should have 5 outputs for step 2', 'Positive Step For Loop: First even number should be "2"', 'Positive Step For Loop: Second even number should be "4"', 'Positive Step For Loop: Final even number should be "10"'],
                'For Loops with Negative Step': ['Negative Step For Loop: Should have 11 outputs for countdown', 'Negative Step For Loop: Countdown should start with "10"', 'Negative Step For Loop: Countdown should end with "0"'],
                'Switch/Case': ['day should be "Mon"', 'First output should be "Monday"', 'Second output should be "Done"']
            };
            
            let html = '';
            
            for (const [categoryName, prefixes] of Object.entries(testCategories)) {
                const categoryTests = testResults.filter(test => 
                    prefixes.some(prefix => test.name.includes(prefix))
                );
                
                if (categoryTests.length > 0) {
                    html += `<div class="test-section">`;
                    html += `<h2>${categoryName}</h2>`;
                    
                    for (const test of categoryTests) {
                        const cssClass = test.passed ? 'test-pass' : 'test-fail';
                        const status = test.passed ? 'âœ… PASS' : 'âŒ FAIL';
                        html += `<div class="test-result ${cssClass}">`;
                        html += `<strong>${status}</strong> - ${test.name}`;
                        if (test.details) {
                            html += `<div class="test-details">${test.details}</div>`;
                        }
                        html += `</div>`;
                    }
                    
                    html += `</div>`;
                }
            }
            
            resultsDiv.innerHTML = html;
            
            // Default to hiding passed tests
            const container = document.querySelector('.container');
            const toggleBtn = document.getElementById('togglePassedBtn');
            
            container.classList.add('hide-passed');
            const passedCount = document.querySelectorAll('.test-result.test-pass').length;
            toggleBtn.textContent = `ğŸ‘ï¸ Show Passed Tests (${passedCount} hidden)`;
            toggleBtn.classList.add('active');
            
            displayTestSummary();
        }
        
        /**
         * Toggle visibility of passed tests
         */
        function togglePassedTests() {
            const container = document.querySelector('.container');
            const toggleBtn = document.getElementById('togglePassedBtn');
            const passedCount = document.querySelectorAll('.test-result.test-pass').length;
            
            if (container.classList.contains('hide-passed')) {
                container.classList.remove('hide-passed');
                toggleBtn.textContent = 'ğŸ™ˆ Hide Passed Tests';
                toggleBtn.classList.remove('active');
            } else {
                container.classList.add('hide-passed');
                toggleBtn.textContent = `ğŸ‘ï¸ Show Passed Tests (${passedCount} hidden)`;
                toggleBtn.classList.add('active');
            }
        }
        
        /**
         * Set up keyboard shortcuts for test management
         */
        function setupKeyboardShortcuts() {
            document.addEventListener('keydown', function(event) {
                if (event.key === 'h' || event.key === 'H') {
                    togglePassedTests();
                } else if (event.key === 'r' || event.key === 'R') {
                    runAllTests();
                }
            });
        }
        
        /**
         * Run all unit tests
         */
        function runAllTests() {
            // Reset state
            resetTestState();
            
            // Run all test categories
            testBasicArithmetic();
            testOperatorPrecedence();
            testParentheses();
            testArrayAccess();
            testStringMethods();
            testForLoopExecution();
            testVariableOperations();
            testComplexExpressions();
            testEdgeCases();
            testTypeConversions();
            testNestedConditionalExecution();
            testStringMethodsInPrint();
            testSubstringWithVariable();
            testComments();
            testConstants();
            testForLoopWithPositiveStep();
            testForLoopWithNegativeStep();
            testSwitchCase();
            
            // Display results
            displayTestResults();
            
            console.log(`âœ… Unit tests completed: ${testsPassed} passed, ${testsFailed} failed`);
        }
        
        // Make functions available globally
        window.runAllTests = runAllTests;
        window.togglePassedTests = togglePassedTests;
        
        // Auto-run tests on page load
        document.addEventListener('DOMContentLoaded', function() {
            setupKeyboardShortcuts();
            runAllTests();
        });
    </script>
</body>
</html>
