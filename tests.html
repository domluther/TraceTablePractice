<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trace Table Practice - Unit Tests</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2d3748;
            margin-bottom: 30px;
        }
        
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }
        
        .test-section h2 {
            color: #4a5568;
            margin-bottom: 15px;
        }
        
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        
        .test-pass {
            background: #c6f6d5;
            color: #2f855a;
            border: 1px solid #9ae6b4;
        }
        
        .test-fail {
            background: #fed7d7;
            color: #c53030;
            border: 1px solid #feb2b2;
        }
        
        .test-summary {
            font-size: 1.2em;
            font-weight: 600;
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
        }
        
        .run-tests-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 20px;
        }
        
        .run-tests-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }
        
        .test-details {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🧪 Trace Table Practice - Unit Tests</h1>
        
        <button class="run-tests-btn" onclick="runAllTests()">🔄 Run All Tests</button>
        
        <div id="testResults"></div>
        
        <div id="testSummary"></div>
    </div>

    <script type="module">
        // Import the actual production Interpreter class
        import { Interpreter } from './js/interpreter.js';
        
        // Test helper functions
        let testResults = [];
        let testsPassed = 0;
        let testsFailed = 0;
        
        // Create an interpreter instance for testing
        const interpreter = new Interpreter();
        
        function assert(condition, testName, details = '') {
            if (condition) {
                testResults.push({
                    name: testName,
                    passed: true,
                    details: details
                });
                testsPassed++;
            } else {
                testResults.push({
                    name: testName,
                    passed: false,
                    details: details
                });
                testsFailed++;
            }
        }
        
        function assertEqual(actual, expected, testName, details = '') {
            const condition = actual === expected;
            const testDetails = details + ` (Expected: ${expected}, Got: ${actual})`;
            assert(condition, testName, testDetails);
        }
        
        function assertArrayEqual(actual, expected, testName, details = '') {
            const condition = JSON.stringify(actual) === JSON.stringify(expected);
            const testDetails = details + ` (Expected: ${JSON.stringify(expected)}, Got: ${JSON.stringify(actual)})`;
            assert(condition, testName, testDetails);
        }
        
        // Test runner functions
        function testBasicArithmetic() {
            const vars = { a: 5, b: 3, c: 2 };
            
            // Test basic addition
            assertEqual(interpreter.evaluateArithmeticExpression('a + b', vars), 8, 'Basic Addition (a + b)');
            
            // Test basic subtraction
            assertEqual(interpreter.evaluateArithmeticExpression('a - b', vars), 2, 'Basic Subtraction (a - b)');
            
            // Test basic multiplication
            assertEqual(interpreter.evaluateArithmeticExpression('a * b', vars), 15, 'Basic Multiplication (a * b)');
            
            // Test basic division
            assertEqual(interpreter.evaluateArithmeticExpression('a / c', vars), 2.5, 'Basic Division (a / c)');
            
            // Test modulo
            assertEqual(interpreter.evaluateArithmeticExpression('a MOD b', vars), 2, 'Basic Modulo (a MOD b)');
            
            // Test exponentiation
            assertEqual(interpreter.evaluateArithmeticExpression('c ^ b', vars), 8, 'Basic Exponentiation (c ^ b)');
        }
        
        function testOperatorPrecedence() {
            const vars = { a: 2, b: 3, c: 4 };
            
            // Test multiplication before addition
            assertEqual(interpreter.evaluateArithmeticExpression('a + b * c', vars), 14, 'Multiplication before Addition (2 + 3 * 4 = 14)');
            
            // Test division before subtraction
            assertEqual(interpreter.evaluateArithmeticExpression('c / a - b', vars), -1, 'Division before Subtraction (4 / 2 - 3 = -1)');
            
            // Test exponentiation before multiplication
            assertEqual(interpreter.evaluateArithmeticExpression('a * b ^ a', vars), 18, 'Exponentiation before Multiplication (2 * 3 ^ 2 = 18)');
            
            // Test left-to-right for same precedence
            assertEqual(interpreter.evaluateArithmeticExpression('a + b - c', vars), 1, 'Left-to-right for Addition/Subtraction (2 + 3 - 4 = 1)');
            assertEqual(interpreter.evaluateArithmeticExpression('a * b / a', vars), 3, 'Left-to-right for Multiplication/Division (2 * 3 / 2 = 3)');
        }
        
        function testParentheses() {
            const vars = { a: 2, b: 3, c: 4 };
            
            // Test basic parentheses
            assertEqual(interpreter.evaluateArithmeticExpression('(a + b) * c', vars), 20, 'Basic Parentheses ((2 + 3) * 4 = 20)');
            
            // Test nested parentheses
            assertEqual(interpreter.evaluateArithmeticExpression('((a + b) * c) / (a + c)', vars), 20/6, 'Nested Parentheses (((2 + 3) * 4) / (2 + 4) = 20/6)');
            
            // Test the rectangle perimeter calculation
            const rectVars = { length: 5, width: 3 };
            assertEqual(interpreter.evaluateArithmeticExpression('2 * (length + width)', rectVars), 16, 'Rectangle Perimeter (2 * (5 + 3) = 16)');
            
            // Test complex expression with parentheses
            assertEqual(interpreter.evaluateArithmeticExpression('(a + b) * (c - a)', vars), 10, 'Complex Parentheses ((2 + 3) * (4 - 2) = 10)');
        }
        
        function testArrayAccess() {
            const vars = { 
                nums: [10, 20, 30], 
                i: 1,
                j: 0
            };
            
            // Test array access with variable index
            assertEqual(interpreter.getExpressionValue('nums[i]', vars), 20, 'Array Access with Variable Index (nums[1] = 20)');
            
            // Test array access with literal index
            assertEqual(interpreter.getExpressionValue('nums[0]', vars), 10, 'Array Access with Literal Index (nums[0] = 10)');
            
            // Test arithmetic with array access
            assertEqual(interpreter.evaluateArithmeticExpression('nums[i] + nums[j]', vars), 30, 'Arithmetic with Array Access (nums[1] + nums[0] = 30)');
            
            // Test complex expression with arrays
            assertEqual(interpreter.evaluateArithmeticExpression('nums[i] * 2', vars), 40, 'Array Access in Multiplication (nums[1] * 2 = 40)');
        }
        
        function testVariableOperations() {
            const vars = { 
                x: 10, 
                y: 0,
                temp: 5
            };
            
            // Test variable assignment expressions
            assertEqual(interpreter.getExpressionValue('x', vars), 10, 'Variable Access (x = 10)');
            assertEqual(interpreter.getExpressionValue('temp', vars), 5, 'Variable Access (temp = 5)');
            
            // Test numeric literals
            assertEqual(interpreter.getExpressionValue('42', vars), 42, 'Numeric Literal (42)');
            assertEqual(interpreter.getExpressionValue('0', vars), 0, 'Numeric Literal (0)');
        }
        
        function testComplexExpressions() {
            const vars = { 
                a: 2, 
                b: 3, 
                c: 4,
                nums: [1, 2, 3, 4, 5],
                index: 2
            };
            
            // Test complex arithmetic expression
            assertEqual(interpreter.evaluateArithmeticExpression('a * b + c * (a + b) - nums[index]', vars), 23, 
                'Complex Expression (2 * 3 + 4 * (2 + 3) - 3 = 23)');
            
            // Test expression with multiple operators
            assertEqual(interpreter.evaluateArithmeticExpression('a ^ b + c / a * nums[0]', vars), 10, 
                'Multiple Operators (2 ^ 3 + 4 / 2 * 1 = 10)');
            
            // Test deeply nested parentheses
            assertEqual(interpreter.evaluateArithmeticExpression('((a + b) * (c - a)) / ((nums[index] + a) - b)', vars), 5, 
                'Deeply Nested (((2 + 3) * (4 - 2)) / ((3 + 2) - 3) = 5)');
        }
        
        function testEdgeCases() {
            const vars = { 
                zero: 0, 
                one: 1, 
                ten: 10,
                emptyArray: [],
                smallArray: [42]
            };
            
            // Test division by one
            assertEqual(interpreter.evaluateArithmeticExpression('ten / one', vars), 10, 'Division by One (10 / 1 = 10)');
            
            // Test multiplication by zero
            assertEqual(interpreter.evaluateArithmeticExpression('ten * zero', vars), 0, 'Multiplication by Zero (10 * 0 = 0)');
            
            // Test power of zero
            assertEqual(interpreter.evaluateArithmeticExpression('ten ^ zero', vars), 1, 'Power of Zero (10 ^ 0 = 1)');
            
            // Test array bounds (should return 0 for out of bounds)
            assertEqual(interpreter.getExpressionValue('emptyArray[0]', vars), 0, 'Empty Array Access (should return 0)');
            assertEqual(interpreter.getExpressionValue('smallArray[5]', vars), 0, 'Out of Bounds Array Access (should return 0)');
        }
        
        function testStringMethods() {
            // Test string concatenation with .left() method (initials bug)
            const vars = {
                first_name: 'John',
                last_name: 'Smith',
                name: 'John',
                count: 4
            };
            
            // Test individual .left() method parts
            const firstInitial = interpreter.evaluateStringConcatenation('first_name.left(1)', vars);
            assertEqual(firstInitial, 'J', 'First name .left(1) should return "J"');
            
            const lastInitial = interpreter.evaluateStringConcatenation('last_name.left(1)', vars);
            assertEqual(lastInitial, 'S', 'Last name .left(1) should return "S"');
            
            // Test the full concatenation (this is the failing case)
            const initials = interpreter.evaluateStringConcatenation('first_name.left(1) + last_name.left(1)', vars);
            assertEqual(initials, 'JS', 'Initials concatenation should return "JS"');
            
            // Test isStringConcatenation detection
            const isStringConcat = interpreter.isStringConcatenation('first_name.left(1) + last_name.left(1)', vars);
            assertEqual(isStringConcat, true, 'Should detect as string concatenation');
            
            // Test other string methods
            assertEqual(interpreter.evaluateStringConcatenation('first_name.upper', vars), 'JOHN', 'String .upper method');
            assertEqual(interpreter.evaluateStringConcatenation('first_name.lower', vars), 'john', 'String .lower method');
            
            // Test that numeric operations still work when string variables exist
            assertEqual(interpreter.evaluateArithmeticExpression('count * 2', vars), 8, 'Numeric Operation with String Variables Present');
            assertEqual(interpreter.evaluateArithmeticExpression('count + 1', vars), 5, 'Addition with String Variables Present');
        }
        
        function testDuckGrouping() {
            // Test duck grouping scenarios (DIV and MOD operators)
            
            // Test with 15 ducks (3 groups of 4, 3 left over)
            assertEqual(interpreter.evaluateArithmeticExpression('15 DIV 4', {}), 3, 'Duck Grouping DIV (15 DIV 4 = 3)');
            assertEqual(interpreter.evaluateArithmeticExpression('15 MOD 4', {}), 3, 'Duck Grouping MOD (15 MOD 4 = 3)');
            
            // Test with 22 ducks (5 groups of 4, 2 left over)
            assertEqual(interpreter.evaluateArithmeticExpression('22 DIV 4', {}), 5, 'Duck Grouping DIV (22 DIV 4 = 5)');
            assertEqual(interpreter.evaluateArithmeticExpression('22 MOD 4', {}), 2, 'Duck Grouping MOD (22 MOD 4 = 2)');
            
            // Test with 8 ducks (2 groups of 4, 0 left over)
            assertEqual(interpreter.evaluateArithmeticExpression('8 DIV 4', {}), 2, 'Duck Grouping DIV (8 DIV 4 = 2)');
            assertEqual(interpreter.evaluateArithmeticExpression('8 MOD 4', {}), 0, 'Duck Grouping MOD (8 MOD 4 = 0)');
            
            // Test with 7 ducks (1 group of 4, 3 left over)
            assertEqual(interpreter.evaluateArithmeticExpression('7 DIV 4', {}), 1, 'Duck Grouping DIV (7 DIV 4 = 1)');
            assertEqual(interpreter.evaluateArithmeticExpression('7 MOD 4', {}), 3, 'Duck Grouping MOD (7 MOD 4 = 3)');
        }

        function testTypeConversions() {
            // Test float() and real() input conversions
            
            // Create a mock program and inputs for testing
            const testProgram = { inputs: ["3.14", "2.5", "10.0"], randomValue: undefined };
            const testInterpreter = new Interpreter();
            
            // Test float(input()) conversion
            const result1 = testInterpreter.executeProgram(`
                x = float(input("Enter number"))
                print(x)
            `, testProgram);
            
            assertEqual(testInterpreter.variables.x, 3.14, 'float(input()) should convert "3.14" to 3.14');
            
            // Test real(input()) conversion  
            const testInterpreter2 = new Interpreter();
            const result2 = testInterpreter2.executeProgram(`
                y = real(input("Enter number"))
                print(y)
            `, testProgram);
            
            assertEqual(testInterpreter2.variables.y, 3.14, 'real(input()) should convert "3.14" to 3.14');
            
            // Test that comparisons work with converted floats
            const testInterpreter3 = new Interpreter();
            const testProgram3 = { inputs: ["3.1", "11"], randomValue: undefined };
            const result3 = testInterpreter3.executeProgram(`
                jumpLength = float(input("Enter jump length"))
                yearGroup = float(input("Enter year group"))
                if jumpLength > 2 then
                    result = "pass"
                else
                    result = "fail"
                endif
                print(result)
            `, testProgram3);
            
            assertEqual(testInterpreter3.variables.jumpLength, 3.1, 'jumpLength should be 3.1 as float');
            assertEqual(testInterpreter3.variables.yearGroup, 11, 'yearGroup should be 11 as float');
            assertEqual(testInterpreter3.variables.result, "pass", 'Comparison 3.1 > 2 should be true');
        }

        function testNestedConditionalExecution() {
            // Test the exact failing scenario from the jump qualification program
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: ["2.2", "8"], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                jumpLength = float(input("Enter jump length"))
                yearGroup = float(input("Enter year group"))
                if jumpLength > 2 then
                    if yearGroup >= 10 then
                        print("You qualify for the team")
                    else
                        print("You are too young")
                    endif
                else
                    print("Jump not long enough")
                endif
            `, testProgram);
            
            // Check variable values
            assertEqual(testInterpreter.variables.jumpLength, 2.2, 'jumpLength should be 2.2');
            assertEqual(testInterpreter.variables.yearGroup, 8, 'yearGroup should be 8');
            
            // Check that the correct message was printed
            assertEqual(testInterpreter.outputs.length, 1, 'Should have exactly 1 output');
            assertEqual(testInterpreter.outputs[0], "You are too young", 'Should print "You are too young" for yearGroup=8');
            
            // Check that the trace table has the correct lines
            // Lines that should execute: 1 (jumpLength=2.2), 2 (yearGroup=8), 7 (else print)
            // Lines that should NOT execute: 3 (if jumpLength>2), 4 (if yearGroup>=10), 5 (print "qualify"), 6 (endif), 8 (endif), 9 (else), 10 (print "not long enough"), 11 (endif)
            
            const executedLines = testInterpreter.trace.map(entry => entry.lineNumber);
            assertEqual(testInterpreter.variables.jumpLength, 2.2, 'jumpLength should be 2.2');
            assertEqual(testInterpreter.variables.yearGroup, 8, 'yearGroup should be 8');
            assertEqual(executedLines.includes(1), true, 'Line 1 should execute (jumpLength assignment)');
            assertEqual(executedLines.includes(2), true, 'Line 2 should execute (yearGroup assignment)');
            assertEqual(executedLines.includes(3), false, 'Line 3 should NOT execute (if condition not traced)');
            assertEqual(executedLines.includes(4), false, 'Line 4 should NOT execute (if condition not traced)');
            assertEqual(executedLines.includes(5), false, 'Line 5 should NOT execute (yearGroup >= 10 is false)');
            assertEqual(executedLines.includes(7), true, 'Line 7 should execute (else branch print)');
        }

        function testForLoopExecution() {
            // Test the basic for loop with arithmetic expression in print statement
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: [], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                for x = 0 to 2
                    print(x*2)
                next x
            `, testProgram);
            
            // Check variable values
            assertEqual(testInterpreter.variables.x, 2, 'x should be 2 after loop completion');
            
            // Check outputs - should have 3 outputs: 0, 2, 4
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], '0', 'First output should be "0"');
            assertEqual(testInterpreter.outputs[1], '2', 'Second output should be "2"');
            assertEqual(testInterpreter.outputs[2], '4', 'Third output should be "4"');
            
            // Check that the trace table has the correct alternating pattern
            // Expected: Line 1 (x=0), Line 2 (print 0), Line 1 (x=1), Line 2 (print 2), Line 1 (x=2), Line 2 (print 4)
            const executedLines = testInterpreter.trace.map(entry => entry.lineNumber);
            
            assertEqual(executedLines.length, 6, 'Should have exactly 6 trace entries');
            assertEqual(executedLines[0], 1, 'First trace should be line 1 (x=0)');
            assertEqual(executedLines[1], 2, 'Second trace should be line 2 (print 0)');
            assertEqual(executedLines[2], 1, 'Third trace should be line 1 (x=1)');
            assertEqual(executedLines[3], 2, 'Fourth trace should be line 2 (print 2)');
            assertEqual(executedLines[4], 1, 'Fifth trace should be line 1 (x=2)');
            assertEqual(executedLines[5], 2, 'Sixth trace should be line 2 (print 4)');
            
            // Check variable changes in trace entries
            assertEqual(testInterpreter.trace[0].changedVariables.x, 0, 'First trace should change x to 0');
            assertEqual(testInterpreter.trace[2].changedVariables.x, 1, 'Third trace should change x to 1');
            assertEqual(testInterpreter.trace[4].changedVariables.x, 2, 'Fifth trace should change x to 2');
            
            // Check outputs in trace entries
            assertEqual(testInterpreter.trace[1].output, '0', 'Second trace should have output "0"');
            assertEqual(testInterpreter.trace[3].output, '2', 'Fourth trace should have output "2"');
            assertEqual(testInterpreter.trace[5].output, '4', 'Sixth trace should have output "4"');
        }

        function testStringMethodsInPrint() {
            // Test string methods directly in print statements
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: ["hello", "WORLD"], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                name = input("Enter name")
                city = input("Enter city")
                print(name.upper)
                print(city.lower)
                print(name.length)
            `, testProgram);
            
            // Check variable values
            assertEqual(testInterpreter.variables.name, 'hello', 'name should be "hello"');
            assertEqual(testInterpreter.variables.city, 'WORLD', 'city should be "WORLD"');
            
            // Check outputs
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], 'HELLO', 'First output should be "HELLO"');
            assertEqual(testInterpreter.outputs[1], 'world', 'Second output should be "world"');
            assertEqual(testInterpreter.outputs[2], '5', 'Third output should be "5"');
            
            // Check trace entries - should trace input assignments and print statements
            const executedLines = testInterpreter.trace.map(entry => entry.lineNumber);
            assertEqual(executedLines.includes(1), true, 'Line 1 should be traced (name input)');
            assertEqual(executedLines.includes(2), true, 'Line 2 should be traced (city input)');
            assertEqual(executedLines.includes(3), true, 'Line 3 should be traced (print name.upper)');
            assertEqual(executedLines.includes(4), true, 'Line 4 should be traced (print city.lower)');
            assertEqual(executedLines.includes(5), true, 'Line 5 should be traced (print name.length)');
            
            // Verify the outputs in trace entries
            const line3Trace = testInterpreter.trace.find(entry => entry.lineNumber === 3);
            const line4Trace = testInterpreter.trace.find(entry => entry.lineNumber === 4);
            const line5Trace = testInterpreter.trace.find(entry => entry.lineNumber === 5);
            
            assertEqual(line3Trace.output, 'HELLO', 'Line 3 trace should have output "HELLO"');
            assertEqual(line4Trace.output, 'world', 'Line 4 trace should have output "world"');
            assertEqual(line5Trace.output, '5', 'Line 5 trace should have output "5"');
        }

        function testSubstringWithVariable() {
            // Test substring method with variable parameters
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: [], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                for x = 1 to 3
                    country = "France"
                    print(country.substring(x, 1))
                next x
            `, testProgram);
            
            // Check variable values
            assertEqual(testInterpreter.variables.x, 3, 'x should be 3 after loop completion');
            assertEqual(testInterpreter.variables.country, 'France', 'country should be "France"');
            
            // Check outputs - should extract characters at positions 1, 2, 3 (r, a, n)
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], 'r', 'First output should be "r" (position 1)');
            assertEqual(testInterpreter.outputs[1], 'a', 'Second output should be "a" (position 2)');
            assertEqual(testInterpreter.outputs[2], 'n', 'Third output should be "n" (position 3)');
            
            // Check trace pattern - now country is only traced when first assigned
            const executedLines = testInterpreter.trace.map(entry => entry.lineNumber);
            assertEqual(executedLines.length, 7, 'Should have exactly 7 trace entries');
            
            // Pattern should be: 1(x=1), 2(country="France"), 3(print), 1(x=2), 3(print), 1(x=3), 3(print)
            // country is only traced once since the value doesn't change
            assertEqual(executedLines[0], 1, 'First trace should be line 1 (x=1)');
            assertEqual(executedLines[1], 2, 'Second trace should be line 2 (country assignment)');
            assertEqual(executedLines[2], 3, 'Third trace should be line 3 (print substring)');
            assertEqual(executedLines[3], 1, 'Fourth trace should be line 1 (x=2)');
            assertEqual(executedLines[4], 3, 'Fifth trace should be line 3 (print substring)');
            assertEqual(executedLines[5], 1, 'Sixth trace should be line 1 (x=3)');
            assertEqual(executedLines[6], 3, 'Seventh trace should be line 3 (print substring)');
            
            // Verify substring outputs in trace entries
            const line3Traces = testInterpreter.trace.filter(entry => entry.lineNumber === 3);
            assertEqual(line3Traces.length, 3, 'Should have 3 traces for line 3');
            assertEqual(line3Traces[0].output, 'r', 'First substring trace should output "r"');
            assertEqual(line3Traces[1].output, 'a', 'Second substring trace should output "a"');
            assertEqual(line3Traces[2].output, 'n', 'Third substring trace should output "n"');
        }
        
        function testComments() {
            const testInterpreter = new Interpreter();
            
            // Test that comments are completely ignored
            const codeWithComments = `// This is a comment
x = 5
// Another comment here
y = 10
// Final comment
z = x + y`;
            
            const result = testInterpreter.execute(codeWithComments);
            
            // Verify that only assignment lines are traced, comments are ignored
            assertEqual(testInterpreter.variables.x, 5, 'x should be 5 despite comments');
            assertEqual(testInterpreter.variables.y, 10, 'y should be 10 despite comments');
            assertEqual(testInterpreter.variables.z, 15, 'z should be 15 (x + y)');
            
            // Check that only 3 trace entries exist (no comment lines)
            assertEqual(testInterpreter.trace.length, 3, 'Should have exactly 3 trace entries (no comments traced)');
            
            // Verify correct line numbers (should skip comment lines)
            assertEqual(testInterpreter.trace[0].lineNumber, 2, 'First trace should be line 2 (x = 5)');
            assertEqual(testInterpreter.trace[1].lineNumber, 4, 'Second trace should be line 4 (y = 10)');
            assertEqual(testInterpreter.trace[2].lineNumber, 6, 'Third trace should be line 6 (z = x + y)');
        }
        
        function testBoolCasting() {
            const testInterpreter = new Interpreter();
            
            // Test bool() with different input types
            const boolTestCode = `// Test bool() casting
isTrue = bool("True")
isFalse = bool("False")
isZero = bool(0)
isOne = bool(1)
isEmpty = bool("")
hasText = bool("hello")
fromVar = bool(isTrue)`;
            
            const result = testInterpreter.execute(boolTestCode);
            
            // Test string conversions
            assertEqual(testInterpreter.variables.isTrue, true, 'bool("True") should be true');
            assertEqual(testInterpreter.variables.isFalse, false, 'bool("False") should be false');
            
            // Test numeric conversions
            assertEqual(testInterpreter.variables.isZero, false, 'bool(0) should be false');
            assertEqual(testInterpreter.variables.isOne, true, 'bool(1) should be true');
            
            // Test variable conversion
            assertEqual(testInterpreter.variables.fromVar, true, 'bool(isTrue) should be true');
            
            // Test case insensitivity
            const caseTestCode = `lowerTrue = bool("true")
upperFalse = bool("FALSE")`;
            const caseResult = testInterpreter.execute(caseTestCode);
            assertEqual(testInterpreter.variables.lowerTrue, true, 'bool("true") should be true (case insensitive)');
            assertEqual(testInterpreter.variables.upperFalse, false, 'bool("FALSE") should be false (case insensitive)');
        }
        
        function testConstants() {
            const testInterpreter = new Interpreter();
            
            // Test constant declaration and usage
            const constCode = `const pi = 3.14159
const vat = 0.2
price = 100
total = price * (1 + vat)
area = pi * 5 * 5`;
            
            const result = testInterpreter.execute(constCode);
            
            // Verify constant values
            assertEqual(testInterpreter.variables.pi, 3.14159, 'const pi should be 3.14159');
            assertEqual(testInterpreter.variables.vat, 0.2, 'const vat should be 0.2');
            
            // Verify calculations using constants
            assertEqual(testInterpreter.variables.total, 120, 'total should be 120 (100 * 1.2)');
            assert(Math.abs(testInterpreter.variables.area - 78.53975) < 0.001, 'area should be approximately 78.54 (pi * 25)');
            
            // Test that constants are tracked
            assert(testInterpreter.constants.pi === true, 'pi should be marked as constant');
            assert(testInterpreter.constants.vat === true, 'vat should be marked as constant');
            assert(testInterpreter.constants.price === undefined, 'price should not be marked as constant');
            
            // Test constant reassignment protection
            const reassignCode = `const x = 5
x = 10
y = x`;
            const reassignResult = testInterpreter.execute(reassignCode);
            
            // Constant should remain unchanged despite reassignment attempt
            assertEqual(testInterpreter.variables.x, 5, 'const x should remain 5 despite reassignment attempt');
            assertEqual(testInterpreter.variables.y, 5, 'y should be 5 (using original x value)');
        }
        
        function testForLoopWithPositiveStep() {
            const testInterpreter = new Interpreter();
            
            // Test for loop with positive step
            const positiveStepCode = `for i = 2 to 10 step 2
    print(i)
next i`;
            
            const result = testInterpreter.execute(positiveStepCode);
            
            // Should print even numbers: 2, 4, 6, 8, 10
            assertEqual(testInterpreter.outputs.length, 5, 'Should have 5 outputs for step 2');
            assertEqual(testInterpreter.outputs[0], '2', 'First output should be "2"');
            assertEqual(testInterpreter.outputs[1], '4', 'Second output should be "4"');
            assertEqual(testInterpreter.outputs[2], '6', 'Third output should be "6"');
            assertEqual(testInterpreter.outputs[3], '8', 'Fourth output should be "8"');
            assertEqual(testInterpreter.outputs[4], '10', 'Fifth output should be "10"');
            
            // Test with step 3
            const step3Code = `for j = 1 to 10 step 3
    print(j)
next j`;
            
            const step3Result = testInterpreter.execute(step3Code);
            assertEqual(testInterpreter.outputs.length, 4, 'Should have 4 outputs for step 3 (1,4,7,10)');
            assertEqual(testInterpreter.outputs[0], '1', 'First output should be "1"');
            assertEqual(testInterpreter.outputs[1], '4', 'Second output should be "4"');
            assertEqual(testInterpreter.outputs[2], '7', 'Third output should be "7"');
            assertEqual(testInterpreter.outputs[3], '10', 'Fourth output should be "10"');
        }
        
        function testForLoopWithNegativeStep() {
            const testInterpreter = new Interpreter();
            
            // Test for loop with negative step (countdown)
            const negativeStepCode = `for i = 10 to 0 step -1
    print(i)
next i`;
            
            const result = testInterpreter.execute(negativeStepCode);
            
            // Should print countdown: 10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0
            assertEqual(testInterpreter.outputs.length, 11, 'Should have 11 outputs for countdown');
            assertEqual(testInterpreter.outputs[0], '10', 'First output should be "10"');
            assertEqual(testInterpreter.outputs[1], '9', 'Second output should be "9"');
            assertEqual(testInterpreter.outputs[9], '1', 'Tenth output should be "1"');
            assertEqual(testInterpreter.outputs[10], '0', 'Eleventh output should be "0"');
            
            // Test with negative step -2
            const step2Code = `for j = 10 to 0 step -2
    print(j)
next j`;
            
            const step2Result = testInterpreter.execute(step2Code);
            assertEqual(testInterpreter.outputs.length, 6, 'Should have 6 outputs for step -2 (10,8,6,4,2,0)');
            assertEqual(testInterpreter.outputs[0], '10', 'First output should be "10"');
            assertEqual(testInterpreter.outputs[1], '8', 'Second output should be "8"');
            assertEqual(testInterpreter.outputs[2], '6', 'Third output should be "6"');
            assertEqual(testInterpreter.outputs[3], '4', 'Fourth output should be "4"');
            assertEqual(testInterpreter.outputs[4], '2', 'Fifth output should be "2"');
            assertEqual(testInterpreter.outputs[5], '0', 'Sixth output should be "0"');
        }
        
        function testForLoopBackwardCompatibility() {
            const testInterpreter = new Interpreter();
            
            // Test that standard for loops still work (no step specified)
            const standardForCode = `for k = 1 to 3
    print(k)
next k`;
            
            const result = testInterpreter.execute(standardForCode);
            
            // Should work like step 1 (default)
            assertEqual(testInterpreter.outputs.length, 3, 'Should have 3 outputs for standard for loop');
            assertEqual(testInterpreter.outputs[0], '1', 'First output should be "1"');
            assertEqual(testInterpreter.outputs[1], '2', 'Second output should be "2"');
            assertEqual(testInterpreter.outputs[2], '3', 'Third output should be "3"');
            
            // Test trace entries for step functionality
            const traceTestCode = `for m = 5 to 7 step 1
    print(m)
next m`;
            
            const traceResult = testInterpreter.execute(traceTestCode);
            
            // Verify trace entries include loop variable changes
            const loopTraces = testInterpreter.trace.filter(entry => entry.lineNumber === 1);
            assertEqual(loopTraces.length, 3, 'Should have 3 traces for loop variable (m=5,6,7)');
            assertEqual(loopTraces[0].changedVariables.m, 5, 'First loop trace should set m=5');
            assertEqual(loopTraces[1].changedVariables.m, 6, 'Second loop trace should set m=6');
            assertEqual(loopTraces[2].changedVariables.m, 7, 'Third loop trace should set m=7');
        }
        
        function testSwitchCase() {
            const testInterpreter = new Interpreter();
            
            // Test basic switch/case with string matching
            const basicSwitchCode = `day = "Mon"
switch day:
case "Mon":
    print("Monday")
case "Tue":
    print("Tuesday")
default:
    print("Unknown day")
endswitch
print("Done")`;
            
            const result = testInterpreter.execute(basicSwitchCode);
            
            // Should match "Mon" case and print "Monday"
            assertEqual(testInterpreter.variables.day, 'Mon', 'day should be "Mon"');
            assertEqual(testInterpreter.outputs.length, 2, 'Should have exactly 2 outputs');
            assertEqual(testInterpreter.outputs[0], 'Monday', 'First output should be "Monday"');
            assertEqual(testInterpreter.outputs[1], 'Done', 'Second output should be "Done"');
            
            // Test default case
            const defaultCaseCode = `color = "purple"
switch color:
case "red":
    print("Stop")
case "green":
    print("Go")
default:
    print("Invalid color")
endswitch`;
            
            const result2 = testInterpreter.execute(defaultCaseCode);
            assertEqual(testInterpreter.variables.color, 'purple', 'color should be "purple"');
            assertEqual(testInterpreter.outputs.length, 1, 'Should have exactly 1 output for default case');
            assertEqual(testInterpreter.outputs[0], 'Invalid color', 'Should execute default case');
            
            // Test switch with no default (no match)
            const noMatchCode = `grade = "X"
switch grade:
case "A":
    print("Excellent")
case "B":
    print("Good")
endswitch
print("Finished")`;
            
            const result3 = testInterpreter.execute(noMatchCode);
            assertEqual(testInterpreter.variables.grade, 'X', 'grade should be "X"');
            assertEqual(testInterpreter.outputs.length, 1, 'Should have 1 output (no case matched)');
            assertEqual(testInterpreter.outputs[0], 'Finished', 'Should only execute after endswitch');
            
            // Test switch inside loop
            const loopSwitchCode = `for i = 1 to 2
    num = str(i)
    switch num:
    case "1":
        print("One")
    case "2":
        print("Two")
    endswitch
next i`;
            
            const result4 = testInterpreter.execute(loopSwitchCode);
            assertEqual(testInterpreter.outputs.length, 2, 'Should have 2 outputs from loop');
            assertEqual(testInterpreter.outputs[0], 'One', 'First loop should print "One"');
            assertEqual(testInterpreter.outputs[1], 'Two', 'Second loop should print "Two"');
        }
        
        function runAllTests() {
            // Reset test results
            testResults = [];
            testsPassed = 0;
            testsFailed = 0;
            
            // Run test suites
            testBasicArithmetic();
            testOperatorPrecedence();
            testParentheses();
            testArrayAccess();
            testVariableOperations();
            testComplexExpressions();
            testEdgeCases();
            testStringMethods();
            testDuckGrouping();
            testTypeConversions();
            testNestedConditionalExecution();
            testForLoopExecution();
            testStringMethodsInPrint();
            testSubstringWithVariable();
            
            // Test newly implemented features
            testComments();
            testBoolCasting();
            testConstants();
            testForLoopWithPositiveStep();
            testForLoopWithNegativeStep();
            testForLoopBackwardCompatibility();
            testSwitchCase();
            testSwitchCase();
            
            // Display results
            displayTestResults();
        }
        
        function displayTestResults() {
            const resultsDiv = document.getElementById('testResults');
            const summaryDiv = document.getElementById('testSummary');
            
            // Group tests by category
            const testSuites = {
                'Basic Arithmetic': ['Basic Addition', 'Basic Subtraction', 'Basic Multiplication', 'Basic Division', 'Basic Modulo', 'Basic Exponentiation'],
                'Operator Precedence': ['Multiplication before Addition', 'Division before Subtraction', 'Exponentiation before Multiplication', 'Left-to-right for Addition/Subtraction', 'Left-to-right for Multiplication/Division'],
                'Parentheses': ['Basic Parentheses', 'Nested Parentheses', 'Rectangle Perimeter', 'Complex Parentheses'],
                'Array Access': ['Array Access with Variable Index', 'Array Access with Literal Index', 'Arithmetic with Array Access', 'Array Access in Multiplication'],
                'Variable Operations': ['Variable Access (x = 10)', 'Variable Access (temp = 5)', 'Numeric Literal (42)', 'Numeric Literal (0)'],
                'Complex Expressions': ['Complex Expression', 'Multiple Operators', 'Deeply Nested'],
                'Edge Cases': ['Division by One', 'Multiplication by Zero', 'Power of Zero', 'Empty Array Access', 'Out of Bounds Array Access'],
                'String Methods': ['First name .left(1) should return "J"', 'Last name .left(1) should return "S"', 'Initials concatenation should return "JS"', 'Should detect as string concatenation', 'String .upper method', 'String .lower method'],
                'String Integration': ['Numeric Operation with String Variables Present', 'Addition with String Variables Present'],
                'Duck Grouping': ['Duck Grouping DIV (15 DIV 4 = 3)', 'Duck Grouping MOD (15 MOD 4 = 3)', 'Duck Grouping DIV (22 DIV 4 = 5)', 'Duck Grouping MOD (22 MOD 4 = 2)', 'Duck Grouping DIV (8 DIV 4 = 2)', 'Duck Grouping MOD (8 MOD 4 = 0)', 'Duck Grouping DIV (7 DIV 4 = 1)', 'Duck Grouping MOD (7 MOD 4 = 3)'],
                'Type Conversions': ['float(input()) should convert "3.14" to 3.14', 'real(input()) should convert "3.14" to 3.14', 'jumpLength should be 3.1 as float', 'yearGroup should be 11', 'Comparison 3.1 > 2 should be true'],
                'Nested Conditionals': ['jumpLength should be 2.2', 'yearGroup should be 8', 'Should have exactly 1 output', 'Should print "You are too young" for yearGroup=8', 'Line 1 should execute (jumpLength assignment)', 'Line 2 should execute (yearGroup assignment)', 'Line 3 should NOT execute (if condition not traced)', 'Line 4 should NOT execute (if condition not traced)', 'Line 5 should NOT execute (yearGroup >= 10 is false)', 'Line 7 should execute (else branch print)'],
                'For Loop Execution': ['x should be 2 after loop completion', 'Should have exactly 3 outputs', 'First output should be "0"', 'Second output should be "2"', 'Third output should be "4"', 'Should have exactly 6 trace entries', 'First trace should be line 1 (x=0)', 'Second trace should be line 2 (print 0)', 'Third trace should be line 1 (x=1)', 'Fourth trace should be line 2 (print 2)', 'Fifth trace should be line 1 (x=2)', 'Sixth trace should be line 2 (print 4)', 'First trace should change x to 0', 'Third trace should change x to 1', 'Fifth trace should change x to 2', 'Second trace should have output "0"', 'Fourth trace should have output "2"', 'Sixth trace should have output "4"'],
                'String Methods in Print': ['name should be "hello"', 'city should be "WORLD"', 'Should have exactly 3 outputs', 'First output should be "HELLO"', 'Second output should be "world"', 'Third output should be "5"', 'Line 1 should be traced (name input)', 'Line 2 should be traced (city input)', 'Line 3 should be traced (print name.upper)', 'Line 4 should be traced (print city.lower)', 'Line 5 should be traced (print name.length)', 'Line 3 trace should have output "HELLO"', 'Line 4 trace should have output "world"', 'Line 5 trace should have output "5"'],
                'Substring with Variables': ['x should be 3 after loop completion', 'country should be "France"', 'Should have exactly 3 outputs', 'First output should be "r" (position 1)', 'Second output should be "a" (position 2)', 'Third output should be "n" (position 3)', 'Should have exactly 7 trace entries', 'First trace should be line 1 (x=1)', 'Second trace should be line 2 (country assignment)', 'Third trace should be line 3 (print substring)', 'Fourth trace should be line 1 (x=2)', 'Fifth trace should be line 3 (print substring)', 'Sixth trace should be line 1 (x=3)', 'Seventh trace should be line 3 (print substring)', 'Should have 3 traces for line 3', 'First substring trace should output "r"', 'Second substring trace should output "a"', 'Third substring trace should output "n"'],
                'Comments': ['x should be 5 despite comments', 'y should be 10 despite comments', 'z should be 15 (x + y)', 'Should have exactly 3 trace entries (no comments traced)', 'First trace should be line 2 (x = 5)', 'Second trace should be line 4 (y = 10)', 'Third trace should be line 6 (z = x + y)'],
                'Bool Casting': ['bool("True") should be true', 'bool("False") should be false', 'bool(0) should be false', 'bool(1) should be true', 'bool(isTrue) should be true', 'bool("true") should be true (case insensitive)', 'bool("FALSE") should be false (case insensitive)'],
                'Constants': ['const pi should be 3.14159', 'const vat should be 0.2', 'total should be 120 (100 * 1.2)', 'area should be approximately 78.54 (pi * 25)', 'pi should be marked as constant', 'vat should be marked as constant', 'price should not be marked as constant', 'const x should remain 5 despite reassignment attempt', 'y should be 5 (using original x value)'],
                'For Loop - Positive Step': ['Should have 5 outputs for step 2', 'First output should be "2"', 'Second output should be "4"', 'Third output should be "6"', 'Fourth output should be "8"', 'Fifth output should be "10"', 'Should have 4 outputs for step 3 (1,4,7,10)', 'First output should be "1"', 'Second output should be "4"', 'Third output should be "7"', 'Fourth output should be "10"'],
                'For Loop - Negative Step': ['Should have 11 outputs for countdown', 'First output should be "10"', 'Second output should be "9"', 'Tenth output should be "1"', 'Eleventh output should be "0"', 'Should have 6 outputs for step -2 (10,8,6,4,2,0)', 'First output should be "10"', 'Second output should be "8"', 'Third output should be "6"', 'Fourth output should be "4"', 'Fifth output should be "2"', 'Sixth output should be "0"'],
                'For Loop - Backward Compatibility': ['Should have 3 outputs for standard for loop', 'First output should be "1"', 'Second output should be "2"', 'Third output should be "3"', 'Should have 3 traces for loop variable (m=5,6,7)', 'First loop trace should set m=5', 'Second loop trace should set m=6', 'Third loop trace should set m=7'],
                'Switch/Case': ['day should be "Mon"', 'Should have exactly 2 outputs', 'First output should be "Monday"', 'Second output should be "Done"', 'color should be "purple"', 'Should have exactly 1 output for default case', 'Should execute default case', 'grade should be "X"', 'Should have 1 output (no case matched)', 'Should only execute after endswitch', 'Should have 2 outputs from loop', 'First loop should print "One"', 'Second loop should print "Two"']
            };
            
            let html = '';
            
            for (const [suiteName, testNames] of Object.entries(testSuites)) {
                html += `<div class="test-section">`;
                html += `<h2>${suiteName}</h2>`;
                
                for (const testName of testNames) {
                    const result = testResults.find(r => r.name.includes(testName.split(' (')[0]));
                    if (result) {
                        const cssClass = result.passed ? 'test-pass' : 'test-fail';
                        const status = result.passed ? '✅ PASS' : '❌ FAIL';
                        html += `<div class="test-result ${cssClass}">`;
                        html += `<strong>${status}</strong> - ${result.name}`;
                        if (result.details) {
                            html += `<div class="test-details">${result.details}</div>`;
                        }
                        html += `</div>`;
                    }
                }
                
                html += `</div>`;
            }
            
            resultsDiv.innerHTML = html;
            
            // Display summary
            const totalTests = testsPassed + testsFailed;
            const passRate = ((testsPassed / totalTests) * 100).toFixed(1);
            const summaryClass = testsFailed === 0 ? 'test-pass' : 'test-fail';
            
            summaryDiv.innerHTML = `
                <div class="test-summary ${summaryClass}">
                    <strong>Test Summary:</strong> ${testsPassed}/${totalTests} tests passed (${passRate}%)
                    ${testsFailed > 0 ? `<br><strong>${testsFailed} tests failed</strong>` : '<br><strong>All tests passed! 🎉</strong>'}
                </div>
            `;
        }
        
        // Make runAllTests available globally for the button
        window.runAllTests = runAllTests;
        
        // Auto-run tests on page load
        document.addEventListener('DOMContentLoaded', function() {
            runAllTests();
        });
    </script>
</body>
</html>
