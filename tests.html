<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Trace Table Practice - Unit Tests</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }
        
        h1 {
            color: #2d3748;
            margin-bottom: 30px;
        }
        
        .test-section {
            margin-bottom: 30px;
            padding: 20px;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
        }
        
        .test-section h2 {
            color: #4a5568;
            margin-bottom: 15px;
        }
        
        .test-result {
            margin: 10px 0;
            padding: 10px;
            border-radius: 4px;
        }
        
        .test-pass {
            background: #c6f6d5;
            color: #2f855a;
            border: 1px solid #9ae6b4;
        }
        
        .test-fail {
            background: #fed7d7;
            color: #c53030;
            border: 1px solid #feb2b2;
        }
        
        .test-summary {
            font-size: 1.2em;
            font-weight: 600;
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
        }
        
        .run-tests-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            margin-bottom: 20px;
        }
        
        .run-tests-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }
        
        .test-details {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 12px;
            color: #666;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🧪 Trace Table Practice - Unit Tests</h1>
        
        <button class="run-tests-btn" onclick="runAllTests()">🔄 Run All Tests</button>
        
        <div id="testResults"></div>
        
        <div id="testSummary"></div>
    </div>

    <script type="module">
        // Import the actual production Interpreter class
        import { Interpreter } from './js/interpreter.js';
        
        // Test helper functions
        let testResults = [];
        let testsPassed = 0;
        let testsFailed = 0;
        
        // Create an interpreter instance for testing
        const interpreter = new Interpreter();
        
        function assert(condition, testName, details = '') {
            if (condition) {
                testResults.push({
                    name: testName,
                    passed: true,
                    details: details
                });
                testsPassed++;
            } else {
                testResults.push({
                    name: testName,
                    passed: false,
                    details: details
                });
                testsFailed++;
            }
        }
        
        function assertEqual(actual, expected, testName, details = '') {
            const condition = actual === expected;
            const testDetails = details + ` (Expected: ${expected}, Got: ${actual})`;
            assert(condition, testName, testDetails);
        }
        
        function assertArrayEqual(actual, expected, testName, details = '') {
            const condition = JSON.stringify(actual) === JSON.stringify(expected);
            const testDetails = details + ` (Expected: ${JSON.stringify(expected)}, Got: ${JSON.stringify(actual)})`;
            assert(condition, testName, testDetails);
        }
        
        // Test runner functions
        function testBasicArithmetic() {
            const vars = { a: 5, b: 3, c: 2 };
            
            // Test basic addition
            assertEqual(interpreter.evaluateArithmeticExpression('a + b', vars), 8, 'Basic Addition (a + b)');
            
            // Test basic subtraction
            assertEqual(interpreter.evaluateArithmeticExpression('a - b', vars), 2, 'Basic Subtraction (a - b)');
            
            // Test basic multiplication
            assertEqual(interpreter.evaluateArithmeticExpression('a * b', vars), 15, 'Basic Multiplication (a * b)');
            
            // Test basic division
            assertEqual(interpreter.evaluateArithmeticExpression('a / c', vars), 2.5, 'Basic Division (a / c)');
            
            // Test modulo
            assertEqual(interpreter.evaluateArithmeticExpression('a MOD b', vars), 2, 'Basic Modulo (a MOD b)');
            
            // Test exponentiation
            assertEqual(interpreter.evaluateArithmeticExpression('c ^ b', vars), 8, 'Basic Exponentiation (c ^ b)');
        }
        
        function testOperatorPrecedence() {
            const vars = { a: 2, b: 3, c: 4 };
            
            // Test multiplication before addition
            assertEqual(interpreter.evaluateArithmeticExpression('a + b * c', vars), 14, 'Multiplication before Addition (2 + 3 * 4 = 14)');
            
            // Test division before subtraction
            assertEqual(interpreter.evaluateArithmeticExpression('c / a - b', vars), -1, 'Division before Subtraction (4 / 2 - 3 = -1)');
            
            // Test exponentiation before multiplication
            assertEqual(interpreter.evaluateArithmeticExpression('a * b ^ a', vars), 18, 'Exponentiation before Multiplication (2 * 3 ^ 2 = 18)');
            
            // Test left-to-right for same precedence
            assertEqual(interpreter.evaluateArithmeticExpression('a + b - c', vars), 1, 'Left-to-right for Addition/Subtraction (2 + 3 - 4 = 1)');
            assertEqual(interpreter.evaluateArithmeticExpression('a * b / a', vars), 3, 'Left-to-right for Multiplication/Division (2 * 3 / 2 = 3)');
        }
        
        function testParentheses() {
            const vars = { a: 2, b: 3, c: 4 };
            
            // Test basic parentheses
            assertEqual(interpreter.evaluateArithmeticExpression('(a + b) * c', vars), 20, 'Basic Parentheses ((2 + 3) * 4 = 20)');
            
            // Test nested parentheses
            assertEqual(interpreter.evaluateArithmeticExpression('((a + b) * c) / (a + c)', vars), 20/6, 'Nested Parentheses (((2 + 3) * 4) / (2 + 4) = 20/6)');
            
            // Test the rectangle perimeter calculation
            const rectVars = { length: 5, width: 3 };
            assertEqual(interpreter.evaluateArithmeticExpression('2 * (length + width)', rectVars), 16, 'Rectangle Perimeter (2 * (5 + 3) = 16)');
            
            // Test complex expression with parentheses
            assertEqual(interpreter.evaluateArithmeticExpression('(a + b) * (c - a)', vars), 10, 'Complex Parentheses ((2 + 3) * (4 - 2) = 10)');
        }
        
        function testArrayAccess() {
            const vars = { 
                nums: [10, 20, 30], 
                i: 1,
                j: 0
            };
            
            // Test array access with variable index
            assertEqual(interpreter.getExpressionValue('nums[i]', vars), 20, 'Array Access with Variable Index (nums[1] = 20)');
            
            // Test array access with literal index
            assertEqual(interpreter.getExpressionValue('nums[0]', vars), 10, 'Array Access with Literal Index (nums[0] = 10)');
            
            // Test arithmetic with array access
            assertEqual(interpreter.evaluateArithmeticExpression('nums[i] + nums[j]', vars), 30, 'Arithmetic with Array Access (nums[1] + nums[0] = 30)');
            
            // Test complex expression with arrays
            assertEqual(interpreter.evaluateArithmeticExpression('nums[i] * 2', vars), 40, 'Array Access in Multiplication (nums[1] * 2 = 40)');
        }
        
        function testVariableOperations() {
            const vars = { 
                x: 10, 
                y: 0,
                temp: 5
            };
            
            // Test variable assignment expressions
            assertEqual(interpreter.getExpressionValue('x', vars), 10, 'Variable Access (x = 10)');
            assertEqual(interpreter.getExpressionValue('temp', vars), 5, 'Variable Access (temp = 5)');
            
            // Test numeric literals
            assertEqual(interpreter.getExpressionValue('42', vars), 42, 'Numeric Literal (42)');
            assertEqual(interpreter.getExpressionValue('0', vars), 0, 'Numeric Literal (0)');
        }
        
        function testComplexExpressions() {
            const vars = { 
                a: 2, 
                b: 3, 
                c: 4,
                nums: [1, 2, 3, 4, 5],
                index: 2
            };
            
            // Test complex arithmetic expression
            assertEqual(interpreter.evaluateArithmeticExpression('a * b + c * (a + b) - nums[index]', vars), 23, 
                'Complex Expression (2 * 3 + 4 * (2 + 3) - 3 = 23)');
            
            // Test expression with multiple operators
            assertEqual(interpreter.evaluateArithmeticExpression('a ^ b + c / a * nums[0]', vars), 10, 
                'Multiple Operators (2 ^ 3 + 4 / 2 * 1 = 10)');
            
            // Test deeply nested parentheses
            assertEqual(interpreter.evaluateArithmeticExpression('((a + b) * (c - a)) / ((nums[index] + a) - b)', vars), 5, 
                'Deeply Nested (((2 + 3) * (4 - 2)) / ((3 + 2) - 3) = 5)');
        }
        
        function testEdgeCases() {
            const vars = { 
                zero: 0, 
                one: 1, 
                ten: 10,
                emptyArray: [],
                smallArray: [42]
            };
            
            // Test division by one
            assertEqual(interpreter.evaluateArithmeticExpression('ten / one', vars), 10, 'Division by One (10 / 1 = 10)');
            
            // Test multiplication by zero
            assertEqual(interpreter.evaluateArithmeticExpression('ten * zero', vars), 0, 'Multiplication by Zero (10 * 0 = 0)');
            
            // Test power of zero
            assertEqual(interpreter.evaluateArithmeticExpression('ten ^ zero', vars), 1, 'Power of Zero (10 ^ 0 = 1)');
            
            // Test array bounds (should return 0 for out of bounds)
            assertEqual(interpreter.getExpressionValue('emptyArray[0]', vars), 0, 'Empty Array Access (should return 0)');
            assertEqual(interpreter.getExpressionValue('smallArray[5]', vars), 0, 'Out of Bounds Array Access (should return 0)');
        }
        
        function testStringMethods() {
            // Test string concatenation with .left() method (initials bug)
            const vars = {
                first_name: 'John',
                last_name: 'Smith',
                name: 'John',
                count: 4
            };
            
            // Test individual .left() method parts
            const firstInitial = interpreter.evaluateStringConcatenation('first_name.left(1)', vars);
            assertEqual(firstInitial, 'J', 'First name .left(1) should return "J"');
            
            const lastInitial = interpreter.evaluateStringConcatenation('last_name.left(1)', vars);
            assertEqual(lastInitial, 'S', 'Last name .left(1) should return "S"');
            
            // Test the full concatenation (this is the failing case)
            const initials = interpreter.evaluateStringConcatenation('first_name.left(1) + last_name.left(1)', vars);
            assertEqual(initials, 'JS', 'Initials concatenation should return "JS"');
            
            // Test isStringConcatenation detection
            const isStringConcat = interpreter.isStringConcatenation('first_name.left(1) + last_name.left(1)', vars);
            assertEqual(isStringConcat, true, 'Should detect as string concatenation');
            
            // Test other string methods
            assertEqual(interpreter.evaluateStringConcatenation('first_name.upper', vars), 'JOHN', 'String .upper method');
            assertEqual(interpreter.evaluateStringConcatenation('first_name.lower', vars), 'john', 'String .lower method');
            
            // Test that numeric operations still work when string variables exist
            assertEqual(interpreter.evaluateArithmeticExpression('count * 2', vars), 8, 'Numeric Operation with String Variables Present');
            assertEqual(interpreter.evaluateArithmeticExpression('count + 1', vars), 5, 'Addition with String Variables Present');
        }
        
        function testDuckGrouping() {
            // Test duck grouping scenarios (DIV and MOD operators)
            
            // Test with 15 ducks (3 groups of 4, 3 left over)
            assertEqual(interpreter.evaluateArithmeticExpression('15 DIV 4', {}), 3, 'Duck Grouping DIV (15 DIV 4 = 3)');
            assertEqual(interpreter.evaluateArithmeticExpression('15 MOD 4', {}), 3, 'Duck Grouping MOD (15 MOD 4 = 3)');
            
            // Test with 22 ducks (5 groups of 4, 2 left over)
            assertEqual(interpreter.evaluateArithmeticExpression('22 DIV 4', {}), 5, 'Duck Grouping DIV (22 DIV 4 = 5)');
            assertEqual(interpreter.evaluateArithmeticExpression('22 MOD 4', {}), 2, 'Duck Grouping MOD (22 MOD 4 = 2)');
            
            // Test with 8 ducks (2 groups of 4, 0 left over)
            assertEqual(interpreter.evaluateArithmeticExpression('8 DIV 4', {}), 2, 'Duck Grouping DIV (8 DIV 4 = 2)');
            assertEqual(interpreter.evaluateArithmeticExpression('8 MOD 4', {}), 0, 'Duck Grouping MOD (8 MOD 4 = 0)');
            
            // Test with 7 ducks (1 group of 4, 3 left over)
            assertEqual(interpreter.evaluateArithmeticExpression('7 DIV 4', {}), 1, 'Duck Grouping DIV (7 DIV 4 = 1)');
            assertEqual(interpreter.evaluateArithmeticExpression('7 MOD 4', {}), 3, 'Duck Grouping MOD (7 MOD 4 = 3)');
        }

        function testTypeConversions() {
            // Test float() and real() input conversions
            
            // Create a mock program and inputs for testing
            const testProgram = { inputs: ["3.14", "2.5", "10.0"], randomValue: undefined };
            const testInterpreter = new Interpreter();
            
            // Test float(input()) conversion
            const result1 = testInterpreter.executeProgram(`
                x = float(input("Enter number"))
                print(x)
            `, testProgram);
            
            assertEqual(testInterpreter.variables.x, 3.14, 'float(input()) should convert "3.14" to 3.14');
            
            // Test real(input()) conversion  
            const testInterpreter2 = new Interpreter();
            const result2 = testInterpreter2.executeProgram(`
                y = real(input("Enter number"))
                print(y)
            `, testProgram);
            
            assertEqual(testInterpreter2.variables.y, 3.14, 'real(input()) should convert "3.14" to 3.14');
            
            // Test that comparisons work with converted floats
            const testInterpreter3 = new Interpreter();
            const testProgram3 = { inputs: ["3.1", "11"], randomValue: undefined };
            const result3 = testInterpreter3.executeProgram(`
                jumpLength = float(input("Enter jump length"))
                yearGroup = float(input("Enter year group"))
                if jumpLength > 2 then
                    result = "pass"
                else
                    result = "fail"
                endif
                print(result)
            `, testProgram3);
            
            assertEqual(testInterpreter3.variables.jumpLength, 3.1, 'jumpLength should be 3.1 as float');
            assertEqual(testInterpreter3.variables.yearGroup, 11, 'yearGroup should be 11 as float');
            assertEqual(testInterpreter3.variables.result, "pass", 'Comparison 3.1 > 2 should be true');
        }

        function testNestedConditionalExecution() {
            // Test the exact failing scenario from the jump qualification program
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: ["2.2", "8"], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                jumpLength = float(input("Enter jump length"))
                yearGroup = float(input("Enter year group"))
                if jumpLength > 2 then
                    if yearGroup >= 10 then
                        print("You qualify for the team")
                    else
                        print("You are too young")
                    endif
                else
                    print("Jump not long enough")
                endif
            `, testProgram);
            
            // Check variable values
            assertEqual(testInterpreter.variables.jumpLength, 2.2, 'jumpLength should be 2.2');
            assertEqual(testInterpreter.variables.yearGroup, 8, 'yearGroup should be 8');
            
            // Check that the correct message was printed
            assertEqual(testInterpreter.outputs.length, 1, 'Should have exactly 1 output');
            assertEqual(testInterpreter.outputs[0], "You are too young", 'Should print "You are too young" for yearGroup=8');
            
            // Check that the trace table has the correct lines
            // Lines that should execute: 1 (jumpLength=2.2), 2 (yearGroup=8), 7 (else print)
            // Lines that should NOT execute: 3 (if jumpLength>2), 4 (if yearGroup>=10), 5 (print "qualify"), 6 (endif), 8 (endif), 9 (else), 10 (print "not long enough"), 11 (endif)
            
            const executedLines = testInterpreter.trace.map(entry => entry.lineNumber);
            assertEqual(testInterpreter.variables.jumpLength, 2.2, 'jumpLength should be 2.2');
            assertEqual(testInterpreter.variables.yearGroup, 8, 'yearGroup should be 8');
            assertEqual(executedLines.includes(1), true, 'Line 1 should execute (jumpLength assignment)');
            assertEqual(executedLines.includes(2), true, 'Line 2 should execute (yearGroup assignment)');
            assertEqual(executedLines.includes(3), false, 'Line 3 should NOT execute (if condition not traced)');
            assertEqual(executedLines.includes(4), false, 'Line 4 should NOT execute (if condition not traced)');
            assertEqual(executedLines.includes(5), false, 'Line 5 should NOT execute (yearGroup >= 10 is false)');
            assertEqual(executedLines.includes(7), true, 'Line 7 should execute (else branch print)');
        }

        function testForLoopExecution() {
            // Test the basic for loop with arithmetic expression in print statement
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: [], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                for x = 0 to 2
                    print(x*2)
                next x
            `, testProgram);
            
            // Check variable values
            assertEqual(testInterpreter.variables.x, 2, 'x should be 2 after loop completion');
            
            // Check outputs - should have 3 outputs: 0, 2, 4
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], '0', 'First output should be "0"');
            assertEqual(testInterpreter.outputs[1], '2', 'Second output should be "2"');
            assertEqual(testInterpreter.outputs[2], '4', 'Third output should be "4"');
            
            // Check that the trace table has the correct alternating pattern
            // Expected: Line 1 (x=0), Line 2 (print 0), Line 1 (x=1), Line 2 (print 2), Line 1 (x=2), Line 2 (print 4)
            const executedLines = testInterpreter.trace.map(entry => entry.lineNumber);
            
            assertEqual(executedLines.length, 6, 'Should have exactly 6 trace entries');
            assertEqual(executedLines[0], 1, 'First trace should be line 1 (x=0)');
            assertEqual(executedLines[1], 2, 'Second trace should be line 2 (print 0)');
            assertEqual(executedLines[2], 1, 'Third trace should be line 1 (x=1)');
            assertEqual(executedLines[3], 2, 'Fourth trace should be line 2 (print 2)');
            assertEqual(executedLines[4], 1, 'Fifth trace should be line 1 (x=2)');
            assertEqual(executedLines[5], 2, 'Sixth trace should be line 2 (print 4)');
            
            // Check variable changes in trace entries
            assertEqual(testInterpreter.trace[0].changedVariables.x, 0, 'First trace should change x to 0');
            assertEqual(testInterpreter.trace[2].changedVariables.x, 1, 'Third trace should change x to 1');
            assertEqual(testInterpreter.trace[4].changedVariables.x, 2, 'Fifth trace should change x to 2');
            
            // Check outputs in trace entries
            assertEqual(testInterpreter.trace[1].output, '0', 'Second trace should have output "0"');
            assertEqual(testInterpreter.trace[3].output, '2', 'Fourth trace should have output "2"');
            assertEqual(testInterpreter.trace[5].output, '4', 'Sixth trace should have output "4"');
        }

        function testStringMethodsInPrint() {
            // Test string methods directly in print statements
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: ["hello", "WORLD"], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                name = input("Enter name")
                city = input("Enter city")
                print(name.upper)
                print(city.lower)
                print(name.length)
            `, testProgram);
            
            // Check variable values
            assertEqual(testInterpreter.variables.name, 'hello', 'name should be "hello"');
            assertEqual(testInterpreter.variables.city, 'WORLD', 'city should be "WORLD"');
            
            // Check outputs
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], 'HELLO', 'First output should be "HELLO"');
            assertEqual(testInterpreter.outputs[1], 'world', 'Second output should be "world"');
            assertEqual(testInterpreter.outputs[2], '5', 'Third output should be "5"');
            
            // Check trace entries - should trace input assignments and print statements
            const executedLines = testInterpreter.trace.map(entry => entry.lineNumber);
            assertEqual(executedLines.includes(1), true, 'Line 1 should be traced (name input)');
            assertEqual(executedLines.includes(2), true, 'Line 2 should be traced (city input)');
            assertEqual(executedLines.includes(3), true, 'Line 3 should be traced (print name.upper)');
            assertEqual(executedLines.includes(4), true, 'Line 4 should be traced (print city.lower)');
            assertEqual(executedLines.includes(5), true, 'Line 5 should be traced (print name.length)');
            
            // Verify the outputs in trace entries
            const line3Trace = testInterpreter.trace.find(entry => entry.lineNumber === 3);
            const line4Trace = testInterpreter.trace.find(entry => entry.lineNumber === 4);
            const line5Trace = testInterpreter.trace.find(entry => entry.lineNumber === 5);
            
            assertEqual(line3Trace.output, 'HELLO', 'Line 3 trace should have output "HELLO"');
            assertEqual(line4Trace.output, 'world', 'Line 4 trace should have output "world"');
            assertEqual(line5Trace.output, '5', 'Line 5 trace should have output "5"');
        }

        function testSubstringWithVariable() {
            // Test substring method with variable parameters
            const testInterpreter = new Interpreter();
            const testProgram = { inputs: [], randomValue: undefined };
            
            const result = testInterpreter.executeProgram(`
                for x = 1 to 3
                    country = "France"
                    print(country.substring(x, 1))
                next x
            `, testProgram);
            
            // Check variable values
            assertEqual(testInterpreter.variables.x, 3, 'x should be 3 after loop completion');
            assertEqual(testInterpreter.variables.country, 'France', 'country should be "France"');
            
            // Check outputs - should extract characters at positions 1, 2, 3 (r, a, n)
            assertEqual(testInterpreter.outputs.length, 3, 'Should have exactly 3 outputs');
            assertEqual(testInterpreter.outputs[0], 'r', 'First output should be "r" (position 1)');
            assertEqual(testInterpreter.outputs[1], 'a', 'Second output should be "a" (position 2)');
            assertEqual(testInterpreter.outputs[2], 'n', 'Third output should be "n" (position 3)');
            
            // Check trace pattern - should alternate between x assignment and print
            const executedLines = testInterpreter.trace.map(entry => entry.lineNumber);
            assertEqual(executedLines.length, 9, 'Should have exactly 9 trace entries');
            
            // Pattern should be: 1(x=1), 2(country="France"), 3(print), 1(x=2), 2(country="France"), 3(print), 1(x=3), 2(country="France"), 3(print)
            assertEqual(executedLines[0], 1, 'First trace should be line 1 (x=1)');
            assertEqual(executedLines[1], 2, 'Second trace should be line 2 (country assignment)');
            assertEqual(executedLines[2], 3, 'Third trace should be line 3 (print substring)');
            assertEqual(executedLines[3], 1, 'Fourth trace should be line 1 (x=2)');
            assertEqual(executedLines[4], 2, 'Fifth trace should be line 2 (country assignment)');
            assertEqual(executedLines[5], 3, 'Sixth trace should be line 3 (print substring)');
            
            // Verify substring outputs in trace entries
            const line3Traces = testInterpreter.trace.filter(entry => entry.lineNumber === 3);
            assertEqual(line3Traces.length, 3, 'Should have 3 traces for line 3');
            assertEqual(line3Traces[0].output, 'r', 'First substring trace should output "r"');
            assertEqual(line3Traces[1].output, 'a', 'Second substring trace should output "a"');
            assertEqual(line3Traces[2].output, 'n', 'Third substring trace should output "n"');
        }
        
        function runAllTests() {
            // Reset test results
            testResults = [];
            testsPassed = 0;
            testsFailed = 0;
            
            // Run test suites
            testBasicArithmetic();
            testOperatorPrecedence();
            testParentheses();
            testArrayAccess();
            testVariableOperations();
            testComplexExpressions();
            testEdgeCases();
            testStringMethods();
            testDuckGrouping();
            testTypeConversions();
            testNestedConditionalExecution();
            testForLoopExecution();
            testStringMethodsInPrint();
            testSubstringWithVariable();
            
            // Display results
            displayTestResults();
        }
        
        function displayTestResults() {
            const resultsDiv = document.getElementById('testResults');
            const summaryDiv = document.getElementById('testSummary');
            
            // Group tests by category
            const testSuites = {
                'Basic Arithmetic': ['Basic Addition', 'Basic Subtraction', 'Basic Multiplication', 'Basic Division', 'Basic Modulo', 'Basic Exponentiation'],
                'Operator Precedence': ['Multiplication before Addition', 'Division before Subtraction', 'Exponentiation before Multiplication', 'Left-to-right for Addition/Subtraction', 'Left-to-right for Multiplication/Division'],
                'Parentheses': ['Basic Parentheses', 'Nested Parentheses', 'Rectangle Perimeter', 'Complex Parentheses'],
                'Array Access': ['Array Access with Variable Index', 'Array Access with Literal Index', 'Arithmetic with Array Access', 'Array Access in Multiplication'],
                'Variable Operations': ['Variable Access (x = 10)', 'Variable Access (temp = 5)', 'Numeric Literal (42)', 'Numeric Literal (0)'],
                'Complex Expressions': ['Complex Expression', 'Multiple Operators', 'Deeply Nested'],
                'Edge Cases': ['Division by One', 'Multiplication by Zero', 'Power of Zero', 'Empty Array Access', 'Out of Bounds Array Access'],
                'String Methods': ['First name .left(1) should return "J"', 'Last name .left(1) should return "S"', 'Initials concatenation should return "JS"', 'Should detect as string concatenation', 'String .upper method', 'String .lower method'],
                'String Integration': ['Numeric Operation with String Variables Present', 'Addition with String Variables Present'],
                'Duck Grouping': ['Duck Grouping DIV (15 DIV 4 = 3)', 'Duck Grouping MOD (15 MOD 4 = 3)', 'Duck Grouping DIV (22 DIV 4 = 5)', 'Duck Grouping MOD (22 MOD 4 = 2)', 'Duck Grouping DIV (8 DIV 4 = 2)', 'Duck Grouping MOD (8 MOD 4 = 0)', 'Duck Grouping DIV (7 DIV 4 = 1)', 'Duck Grouping MOD (7 MOD 4 = 3)'],
                'Type Conversions': ['float(input()) should convert "3.14" to 3.14', 'real(input()) should convert "3.14" to 3.14', 'jumpLength should be 3.1 as float', 'yearGroup should be 11 as float', 'Comparison 3.1 > 2 should be true'],
                'Nested Conditionals': ['jumpLength should be 2.2', 'yearGroup should be 8', 'Should have exactly 1 output', 'Should print "You are too young" for yearGroup=8', 'Line 1 should execute (jumpLength assignment)', 'Line 2 should execute (yearGroup assignment)', 'Line 3 should NOT execute (if condition not traced)', 'Line 4 should NOT execute (if condition not traced)', 'Line 5 should NOT execute (yearGroup >= 10 is false)', 'Line 7 should execute (else branch print)'],
                'For Loop Execution': ['x should be 2 after loop completion', 'Should have exactly 3 outputs', 'First output should be "0"', 'Second output should be "2"', 'Third output should be "4"', 'Should have exactly 6 trace entries', 'First trace should be line 1 (x=0)', 'Second trace should be line 2 (print 0)', 'Third trace should be line 1 (x=1)', 'Fourth trace should be line 2 (print 2)', 'Fifth trace should be line 1 (x=2)', 'Sixth trace should be line 2 (print 4)', 'First trace should change x to 0', 'Third trace should change x to 1', 'Fifth trace should change x to 2', 'Second trace should have output "0"', 'Fourth trace should have output "2"', 'Sixth trace should have output "4"'],
                'String Methods in Print': ['name should be "hello"', 'city should be "WORLD"', 'Should have exactly 3 outputs', 'First output should be "HELLO"', 'Second output should be "world"', 'Third output should be "5"', 'Line 1 should be traced (name input)', 'Line 2 should be traced (city input)', 'Line 3 should be traced (print name.upper)', 'Line 4 should be traced (print city.lower)', 'Line 5 should be traced (print name.length)', 'Line 3 trace should have output "HELLO"', 'Line 4 trace should have output "world"', 'Line 5 trace should have output "5"'],
                'Substring with Variables': ['x should be 3 after loop completion', 'country should be "France"', 'Should have exactly 3 outputs', 'First output should be "r" (position 1)', 'Second output should be "a" (position 2)', 'Third output should be "n" (position 3)', 'Should have exactly 9 trace entries', 'First trace should be line 1 (x=1)', 'Second trace should be line 2 (country assignment)', 'Third trace should be line 3 (print substring)', 'Fourth trace should be line 1 (x=2)', 'Fifth trace should be line 2 (country assignment)', 'Sixth trace should be line 3 (print substring)', 'Should have 3 traces for line 3', 'First substring trace should output "r"', 'Second substring trace should output "a"', 'Third substring trace should output "n"']
            };
            
            let html = '';
            
            for (const [suiteName, testNames] of Object.entries(testSuites)) {
                html += `<div class="test-section">`;
                html += `<h2>${suiteName}</h2>`;
                
                for (const testName of testNames) {
                    const result = testResults.find(r => r.name.includes(testName.split(' (')[0]));
                    if (result) {
                        const cssClass = result.passed ? 'test-pass' : 'test-fail';
                        const status = result.passed ? '✅ PASS' : '❌ FAIL';
                        html += `<div class="test-result ${cssClass}">`;
                        html += `<strong>${status}</strong> - ${result.name}`;
                        if (result.details) {
                            html += `<div class="test-details">${result.details}</div>`;
                        }
                        html += `</div>`;
                    }
                }
                
                html += `</div>`;
            }
            
            resultsDiv.innerHTML = html;
            
            // Display summary
            const totalTests = testsPassed + testsFailed;
            const passRate = ((testsPassed / totalTests) * 100).toFixed(1);
            const summaryClass = testsFailed === 0 ? 'test-pass' : 'test-fail';
            
            summaryDiv.innerHTML = `
                <div class="test-summary ${summaryClass}">
                    <strong>Test Summary:</strong> ${testsPassed}/${totalTests} tests passed (${passRate}%)
                    ${testsFailed > 0 ? `<br><strong>${testsFailed} tests failed</strong>` : '<br><strong>All tests passed! 🎉</strong>'}
                </div>
            `;
        }
        
        // Make runAllTests available globally for the button
        window.runAllTests = runAllTests;
        
        // Auto-run tests on page load
        document.addEventListener('DOMContentLoaded', function() {
            runAllTests();
        });
    </script>
</body>
</html>
