<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GCSE Computer Science - Trace Table Practice</title>
    <link rel="icon" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIiIGhlaWdodD0iMzIiIHZpZXdCb3g9IjAgMCAzMiAzMiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KICA8IS0tIEJhY2tncm91bmQgLS0+CiAgPHJlY3Qgd2lkdGg9IjMyIiBoZWlnaHQ9IjMyIiByeD0iNCIgZmlsbD0iIzI5NGE2OCIvPgogIDwhLS0gVGFibGUgZ3JpZCAtLT4KICA8cmVjdCB4PSI0IiB5PSI2IiB3aWR0aD0iMjQiIGhlaWdodD0iMjAiIGZpbGw9Im5vbmUiIHN0cm9rZT0iI2Y5ZmJmZiIgc3Ryb2tlLXdpZHRoPSIxLjUiLz4KICA8IS0tIEhvcml6b250YWwgbGluZXMgLS0+CiAgPGxpbmUgeDE9IjQiIHkxPSIxMCIgeDI9IjI4IiB5Mj0iMTAiIHN0cm9rZT0iI2Y5ZmJmZiIgc3Ryb2tlLXdpZHRoPSIxIi8+CiAgPGxpbmUgeDE9IjQiIHkxPSIxNCIgeDI9IjI4IiB5Mj0iMTQiIHN0cm9rZT0iI2Y5ZmJmZiIgc3Ryb2tlLXdpZHRoPSIxIi8+CiAgPGxpbmUgeDE9IjQiIHkxPSIxOCIgeDI9IjI4IiB5Mj0iMTgiIHN0cm9rZT0iI2Y5ZmJmZiIgc3Ryb2tlLXdpZHRoPSIxIi8+CiAgPGxpbmUgeDE9IjQiIHkxPSIyMiIgeDI9IjI4IiB5Mj0iMjIiIHN0cm9rZT0iI2Y5ZmJmZiIgc3Ryb2tlLXdpZHRoPSIxIi8+CiAgPCEtLSBWZXJ0aWNhbCBsaW5lcyAtLT4KICA8bGluZSB4MT0iMTAiIHkxPSI2IiB4Mj0iMTAiIHkyPSIyNiIgc3Ryb2tlPSIjZjlmYmZmIiBzdHJva2Utd2lkdGg9IjEiLz4KICA8bGluZSB4MT0iMTYiIHkxPSI2IiB4Mj0iMTYiIHkyPSIyNiIgc3Ryb2tlPSIjZjlmYmZmIiBzdHJva2Utd2lkdGg9IjEiLz4KICA8bGluZSB4MT0iMjIiIHkxPSI2IiB4Mj0iMjIiIHkyPSIyNiIgc3Ryb2tlPSIjZjlmYmZmIiBzdHJva2Utd2lkdGg9IjEiLz4KICA8IS0tIEhlYWRlciB0ZXh0IC0tPgogIDx0ZXh0IHg9IjciIHk9IjkiIGZvbnQtZmFtaWx5PSJtb25vc3BhY2UiIGZvbnQtc2l6ZT0iMyIgZmlsbD0iIzkwY2RmNCIgZm9udC13ZWlnaHQ9ImJvbGQiPkwjPC90ZXh0PgogIDx0ZXh0IHg9IjEzIiB5PSI5IiBmb250LWZhbWlseT0ibW9ub3NwYWNlIiBmb250LXNpemU9IjMiIGZpbGw9IiM5MGNkZjQiIGZvbnQtd2VpZ2h0PSJib2xkIj5YPC90ZXh0PgogIDx0ZXh0IHg9IjE5IiB5PSI5IiBmb250LWZhbWlseT0ibW9ub3NwYWNlIiBmb250LXNpemU9IjMiIGZpbGw9IiM5MGNkZjQiIGZvbnQtd2VpZ2h0PSJib2xkIj5PPC90ZXh0PgogIDx0ZXh0IHg9IjI1IiB5PSI5IiBmb250LWZhbWlseT0ibW9ub3NwYWNlIiBmb250LXNpemU9IjMiIGZpbGw9IiM5MGNkZjQiIGZvbnQtd2VpZ2h0PSJib2xkIj4+PC90ZXh0PgogIDwhLS0gU2FtcGxlIGRhdGEgLS0+CiAgPHRleHQgeD0iNyIgeT0iMTMiIGZvbnQtZmFtaWx5PSJtb25vc3BhY2UiIGZvbnQtc2l6ZT0iMyIgZmlsbD0iI2Y5ZmJmZiI+MTwvdGV4dD4KICA8dGV4dCB4PSIxMyIgeT0iMTMiIGZvbnQtZmFtaWx5PSJtb25vc3BhY2UiIGZvbnQtc2l6ZT0iMyIgZmlsbD0iI2Y5ZmJmZiI+NTwvdGV4dD4KICA8dGV4dCB4PSIxOSIgeT0iMTMiIGZvbnQtZmFtaWx5PSJtb25vc3BhY2UiIGZvbnQtc2l6ZT0iMyIgZmlsbD0iI2Y5ZmJmZiI+NS90ZXh0PgogIDx0ZXh0IHg9IjciIHk9IjE3IiBmb250LWZhbWlseT0ibW9ub3NwYWNlIiBmb250LXNpemU9IjMiIGZpbGw9IiNmOWZiZmYiPjI8L3RleHQ+CiAgPHRleHQgeD0iMTMiIHk9IjE3IiBmb250LWZhbWlseT0ibW9ub3NwYWNlIiBmb250LXNpemU9IjMiIGZpbGw9IiNmOWZiZmYiPjEwPC90ZXh0PgogIDx0ZXh0IHg9IjE5IiB5PSIxNyIgZm9udC1mYW1pbHk9Im1vbm9zcGFjZSIgZm9udC1zaXplPSIzIiBmaWxsPSIjZjlmYmZmIj4xMDwvdGV4dD4KICA8dGV4dCB4PSI3IiB5PSIyMSIgZm9udC1mYW1pbHk9Im1vbm9zcGFjZSIgZm9udC1zaXplPSIzIiBmaWxsPSIjZjlmYmZmIj4zPC90ZXh0PgogIDx0ZXh0IHg9IjEzIiB5PSIyMSIgZm9udC1mYW1pbHk9Im1vbm9zcGFjZSIgZm9udC1zaXplPSIzIiBmaWxsPSIjZjlmYmZmIj4xNTwvdGV4dD4KICA8dGV4dCB4PSIxOSIgeT0iMjEiIGZvbnQtZmFtaWx5PSJtb25vc3BhY2UiIGZvbnQtc2l6ZT0iMyIgZmlsbD0iI2Y5ZmJmZiI+MTU8L3RleHQ+Cjwvc3ZnPgo=" type="image/svg+xml">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.2);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #2d3748 0%, #1a202c 100%);
            color: white;
            padding: 20px 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.2em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .content {
            padding: 30px;
        }

        .controls {
            display: flex;
            gap: 15px;
            margin-bottom: 30px;
            flex-wrap: wrap;
            align-items: center;
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.2);
        }

        .btn-success {
            background: linear-gradient(135deg, #48bb78 0%, #38a169 100%);
            color: white;
        }

        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(72, 187, 120, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, #ed8936 0%, #dd6b20 100%);
            color: white;
        }

        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(237, 137, 54, 0.4);
        }

        .difficulty-selector,
        .mode-selector,
        .program-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .difficulty-selector label,
        .mode-selector label,
        .program-selector label {
            font-weight: 600;
            color: #2d3748;
        }

        .difficulty-selector select,
        .mode-selector select,
        .program-selector select {
            padding: 8px 12px;
            border: 2px solid #e2e8f0;
            border-radius: 6px;
            font-size: 14px;
            background: white;
        }

        .code-section {
            background: #1a202c;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .code-section h3 {
            color: #90cdf4;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .code-display {
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
            line-height: 1.6;
            color: #e2e8f0;
            background: #2d3748;
            padding: 15px;
            border-radius: 8px;
            overflow-x: auto;
            white-space: pre;
        }

        .line-number {
            color: #90cdf4;
            margin-right: 15px;
            user-select: none;
        }

        .trace-section {
            margin-bottom: 30px;
        }

        .trace-section h3 {
            color: #2d3748;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .trace-table {
            width: 100%;
            border-collapse: collapse;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .trace-table th {
            background: linear-gradient(135deg, #4a5568 0%, #2d3748 100%);
            color: white;
            padding: 12px;
            text-align: center;
            font-weight: 600;
        }

        .trace-table td {
            padding: 10px;
            text-align: center;
            border-bottom: 1px solid #e2e8f0;
        }

        .trace-table input {
            width: 100%;
            padding: 8px;
            border: 1px solid #cbd5e0;
            border-radius: 4px;
            text-align: center;
            font-size: 14px;
        }

        .trace-table input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .trace-table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .feedback {
            margin-top: 20px;
            padding: 15px;
            border-radius: 8px;
            display: none;
        }

        .feedback.success {
            background: #c6f6d5;
            color: #2f855a;
            border: 1px solid #9ae6b4;
        }

        .feedback.error {
            background: #fed7d7;
            color: #c53030;
            border: 1px solid #feb2b2;
        }

        .score {
            font-size: 1.2em;
            font-weight: 600;
            text-align: center;
            margin-top: 10px;
        }

        .instructions {
            background: #edf2f7;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 30px;
            border-left: 4px solid #667eea;
        }

        .instructions-header {
            color: #2d3748;
            margin-bottom: 10px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: color 0.2s ease;
        }

        .instructions-header:hover {
            color: #667eea;
        }

        .instructions-content {
            overflow: hidden;
            transition: max-height 0.3s ease;
            max-height: 200px; /* Initial expanded height */
        }

        .instructions-content.collapsed {
            max-height: 0;
            padding-top: 0;
            padding-bottom: 0;
        }

        .instructions h4 {
            color: #2d3748;
            margin-bottom: 10px;
        }

        .instructions ul {
            color: #4a5568;
            margin-left: 20px;
        }

        .instructions li {
            margin-bottom: 5px;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            
            .difficulty-selector {
                justify-content: center;
            }
            
            .code-display {
                font-size: 12px;
            }
            
            .trace-table {
                font-size: 12px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ Mr Luther's OCR J277 Trace Table Practice Page</h1>
            <p>Practice coding in OCR ERL <a href="https://www.examreferencelanguage.co.uk/"> here </a></p>
        </div>

        <div class="content">
            <div class="instructions">
                <h4 class="instructions-header" onclick="toggleInstructions()">
                    üìã Instructions: <span id="instructions-toggle">‚ñº</span>
                </h4>
                <div id="instructions-content" class="instructions-content">
                    <ul>
                        <li>Select difficulty level (Easy/Medium/Hard)</li>
                        <li>Choose between "Random" mode or "Select Program" mode</li>
                        <li>In Select mode, choose a specific program from the dropdown</li>
                        <li>Click "Generate" to try your chosen program</li>
                        <li>Trace through the code step by step</li>
                        <li>Fill in the trace table with variable values and outputs</li>
                        <li>Click "Mark Answer" to check your solution</li>
                        <li>Use "Clear Table" to reset all inputs if needed</li>
                    </ul>
                </div>
            </div>

            <div class="controls">
                <div class="difficulty-selector">
                    <label for="difficulty">Difficulty:</label>
                    <select id="difficulty" onchange="updateProgramSelector()">
                        <option value="easy">Easy</option>
                        <option value="medium">Medium</option>
                        <option value="hard">Hard</option>
                    </select>
                </div>
                <div class="mode-selector">
                    <label for="mode">Mode:</label>
                    <select id="mode" onchange="toggleProgramSelector()">
                        <option value="random">Random</option>
                        <option value="select">Select Program</option>
                    </select>
                </div>
                <div class="program-selector" id="programSelector" style="display: none;">
                    <label for="programChoice">Program:</label>
                    <select id="programChoice">
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>
                <button class="btn btn-primary" onclick="generateProgram()">üîÑ Generate</button>
            </div>

            <div class="code-section">
                <h3>üíª Program Code</h3>
                <div class="code-display" id="codeDisplay">
                    Click "Generate" to start!
                </div>
            </div>

            <div class="trace-section">
                <h3>üìä Trace Table</h3>
                <table class="trace-table" id="traceTable">
                    <thead>
                        <tr>
                            <th>Line Number</th>
                            <th>Output</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Table rows will be generated dynamically -->
                    </tbody>
                </table>
                
                <div class="table-controls" style="margin-top: 20px; display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                    <button class="btn btn-success" onclick="markAnswer()">‚úÖ Mark Answer</button>
                    <button class="btn btn-warning" onclick="clearTable()">üóëÔ∏è Clear Table</button>
                </div>
            </div>

            <div class="feedback" id="feedback">
                <div class="score" id="score"></div>
                <div id="feedbackText"></div>
            </div>
        </div>
    </div>

    <script>
        let currentProgram = null;
        let expectedTrace = [];
        let programVariables = [];

        // Toggle instructions visibility
        function toggleInstructions() {
            const content = document.getElementById('instructions-content');
            const toggle = document.getElementById('instructions-toggle');
            
            if (content.classList.contains('collapsed')) {
                // Expand
                content.classList.remove('collapsed');
                content.style.maxHeight = content.scrollHeight + 'px';
                toggle.textContent = '‚ñº';
            } else {
                // Collapse
                content.style.maxHeight = '0px';
                content.classList.add('collapsed');
                toggle.textContent = '‚ñ∂';
            }
        }

        // Initialize instructions as expanded with proper max-height
        document.addEventListener('DOMContentLoaded', function() {
            const content = document.getElementById('instructions-content');
            // Set initial max-height to the actual content height
            content.style.maxHeight = content.scrollHeight + 'px';
        });

        const programs = {
            easy: [
                {
                    code: `a = 5
b = 3
c = a + b
print(c)`,
                    description: "Simple arithmetic"
                },
                {
                    code: `name = "Alice"
age = 16
print("Hello " + name)
print("You are " + str(age))`,
                    description: "String concatenation"
                },
                {
                    code: `x = 10
y = 20
temp = x
x = y
y = temp
print(x)
print(y)`,
                    description: "Variable swapping"
                },
                {
                    code: `name = input("What's your name?")
print("Hello " + name)`,
                    description: "Simple input and output",
                    inputSets: [
                        ["Alice"],
                        ["Bob"],
                        ["Charlie"],
                        ["Diana"]
                    ]
                },
                {
                    code: `age = int(input("How old are you?"))
if age < 18 then
    print("You are a student!")
else
    print("You finished school")
endif`,
                    description: "Age checker with conditions",
                    inputSets: [
                        ["16"],
                        ["20"],
                        ["17"],
                        ["25"]
                    ]
                },
                {
                    code: `test1 = int(input("What score?"))
test2 = int(input("What score?"))
total = test1 + test2
print("You got " + str(total))`,
                    description: "Adding two test scores",
                    inputSets: [
                        ["75", "82"],
                        ["90", "88"],
                        ["65", "70"],
                        ["95", "92"]
                    ]
                }
            ],
            medium: [
                {
                    code: `total = 0
for i = 1 to 3
    total = total + i
    print(total)
next i
print("Final: " + str(total))`,
                    description: "For loop with accumulator"
                },
                {
                    code: `count = 0
while count < 3
    count = count + 1
    print("Count: " + str(count))
endwhile
print("Finished counting")`,
                    description: "While loop with counter"
                },
                {
                    code: `score = 75
if score >= 90 then
    print("Grade A")
elseif score >= 70 then
    print("Grade B")
else
    print("Grade C")
endif
print("Score: " + str(score))`,
                    description: "If-elseif-else statements"
                },
                {
                    code: `surname = input("Enter surname")
year = input("Enter starting year")
staffID = surname + str(year)
while staffID.length < 10
    staffID = staffID + "x"
endwhile
print("ID " + staffID)`,
                    description: "Staff ID generator with input",
                    inputSets: [
                        ["Kofi", "2021"],
                        ["Smith", "2023"],
                        ["Lee", "2020"],
                        ["Brown", "2024"]
                    ]
                },
                {
                    code: `x = 15
y = 0
while x > 0
    y = y + 1
    x = x - y
endwhile
print(y)`,
                    description: "While loop with variable decrement"
                },
                {
                    code: `a = input("Enter first letter of first name")
b = input("Enter first letter of second name")
c = random(1,100)
while c < 100
    c = c * 10
endwhile
pilotCode = a + b + str(c)
print(pilotCode)`,
                    description: "Pilot code generator with random",
                    inputSets: [
                        ["S", "T"],
                        ["A", "B"],
                        ["J", "M"],
                        ["K", "R"]
                    ],
                    randomValues: [4, 7, 12, 25, 50]
                },
                {
                    code: `jumpLength = input("Enter jump length")
yearGroup = input("Enter year group")
if jumpLength > 2 then
    if yearGroup >= 10 then
        print("You qualify for the team")
    else
        print("You are too young")
    endif
else
    print("Jump not long enough")
endif`,
                    description: "Long jump qualification",
                    inputSets: [
                        ["2.5", "9"],
                        ["3.1", "11"],
                        ["1.8", "10"],
                        ["2.2", "8"]
                    ]
                },
                {
                    code: `longJump = input("Enter distance")
yearGroup = input("Enter year group")
if longJump >= 5.0 then
    score = 3
elseif longJump >= 3.0 then
    score = 2
else
    score = 1
endif
if yearGroup != 10 then
    score = score * 2
endif
print("The score is", score)`,
                    description: "Long jump scoring system",
                    inputSets: [
                        ["2.5", "9"],
                        ["5.2", "10"],
                        ["3.8", "11"],
                        ["1.9", "8"]
                    ]
                },
                {
                    code: `for x = 0 to 2
    print(x*2)
next x`,
                    description: "For loop with multiplication"
                },
                {
                    code: `for x = 0 to 5
    if x < 3 then
        print("less than 3")
    else
        print("3 or above")
    endif
next x`,
                    description: "For loop with conditional output"
                },
                {
                    code: `for x = 0 to 2
    choice = input("Enter a word")
    case = input("upper or lower")
    if case == "upper" then
        print(choice.upper)
    else
        print(choice.lower)
    endif
next x`,
                    description: "For loop with string methods",
                    inputSets: [
                        ["hello", "upper", "world", "lower", "test", "upper"],
                        ["cat", "lower", "DOG", "upper", "fish", "lower"],
                        ["APPLE", "lower", "banana", "upper", "Orange", "lower"],
                        ["yes", "upper", "NO", "lower", "maybe", "upper"]
                    ]
                },
                {
                    code: `for x = 1 to 3
    country = "France"
    print(country[x])
next x`,
                    description: "Array indexing with string"
                }
            ],
            hard: [
                {
                    code: `array nums[3]
nums[0] = 10
nums[1] = 20
nums[2] = 30
total = 0
for i = 0 to 2
    total = total + nums[i]
    print("Sum so far: " + str(total))
next i
print("Average: " + str(total / 3))`,
                    description: "Array processing"
                },
                {
                    code: `function factorial(n)
    if n <= 1
        return 1
    else
        return n * factorial(n - 1)
    endif
endfunction
result = factorial(4)
print("4! = " + str(result))`,
                    description: "Recursive function"
                },
                {
                    code: `do
    x = input("Password: ")
    print("You guessed " + x)
until x == "parrot"
print("Correct!")`,
                    description: "Do-until loop with password check",
                    inputSets: [
                        ["hello", "123", "parrot"],
                        ["password", "parrot"],
                        ["wrong", "guess", "test", "parrot"],
                        ["abc", "parrot"]
                    ]
                }
            ]
        };

        function generateProgram() {
            const difficulty = document.getElementById('difficulty').value;
            const mode = document.getElementById('mode').value;
            const programList = programs[difficulty];
            
            let randomProgram;
            
            if (mode === 'select') {
                const selectedIndex = parseInt(document.getElementById('programChoice').value);
                randomProgram = programList[selectedIndex];
            } else {
                // Random mode
                randomProgram = programList[Math.floor(Math.random() * programList.length)];
            }
            
            currentProgram = { ...randomProgram };
            
            // If the program has multiple input sets, randomly select one
            if (currentProgram.inputSets && currentProgram.inputSets.length > 0) {
                const randomInputSet = currentProgram.inputSets[Math.floor(Math.random() * currentProgram.inputSets.length)];
                currentProgram.inputs = randomInputSet;
            }
            
            // If the program has multiple random values, randomly select one
            if (currentProgram.randomValues && currentProgram.randomValues.length > 0) {
                const randomValue = currentProgram.randomValues[Math.floor(Math.random() * currentProgram.randomValues.length)];
                currentProgram.randomValue = randomValue;
            }
            
            displayCode(currentProgram.code);
            executeProgram(currentProgram.code);
            createTraceTable();
            
            // Hide feedback
            document.getElementById('feedback').style.display = 'none';
        }

        function displayCode(code) {
            const lines = code.split('\n');
            let numberedCode = '';
            
            lines.forEach((line, index) => {
                numberedCode += `<span class="line-number">${index + 1}</span>${line}\n`;
            });
            
            // Add input values display if available
            if (currentProgram.inputs && currentProgram.inputs.length > 0) {
                numberedCode += `\n<span style="color: #90cdf4;">Input values: ${currentProgram.inputs.map(input => `"${input}"`).join(', ')}</span>`;
            }
            
            // Add random value display if available
            if (currentProgram.randomValue !== undefined) {
                numberedCode += `\n<span style="color: #90cdf4;">Random value: ${currentProgram.randomValue}</span>`;
            }
            
            document.getElementById('codeDisplay').innerHTML = numberedCode;
        }

        function executeProgram(code) {
            // Simple interpreter for trace table generation
            const lines = code.split('\n').map(line => line.trim()).filter(line => line);
            const variables = {};
            const outputs = [];
            const trace = [];
            
            // Get predefined inputs if available
            const inputs = currentProgram.inputs || [];
            let inputIndex = 0;
            
            function addTraceEntry(lineNum, vars, output = '') {
                trace.push({
                    lineNumber: lineNum,
                    variables: { ...vars },
                    output: output
                });
            }
            
            function executeStatement(line, lineNum, vars) {
                let output = '';
                
                if (line.includes('=') && !line.includes('==') && !line.includes('!=') && !line.includes('<=') && !line.includes('>=')) {
                    // Assignment
                    const parts = line.split('=');
                    const varName = parts[0].trim();
                    const value = parts[1].trim();
                    
                    if (value.startsWith('input(')) {
                        // Input statement - use predefined input value
                        if (inputIndex < inputs.length) {
                            vars[varName] = inputs[inputIndex];
                            inputIndex++;
                        } else {
                            vars[varName] = "undefined_input";
                        }
                    } else if (value.startsWith('int(input(')) {
                        // int(input()) statement - use predefined input value and convert to integer
                        if (inputIndex < inputs.length) {
                            vars[varName] = parseInt(inputs[inputIndex]);
                            inputIndex++;
                        } else {
                            vars[varName] = 0;
                        }
                    } else if (value.startsWith('random(')) {
                        // Random function - use predefined random value if available
                        if (currentProgram.randomValue !== undefined) {
                            vars[varName] = currentProgram.randomValue;
                        } else {
                            // Parse the random range and use the minimum value for consistency
                            const match = value.match(/random\((\d+),\s*(\d+)\)/);
                            if (match) {
                                const min = parseInt(match[1]);
                                vars[varName] = min; // Use minimum for deterministic results
                            } else {
                                vars[varName] = 1; // Default fallback
                            }
                        }
                    } else if (value.startsWith('"') && value.endsWith('"')) {
                        vars[varName] = value.slice(1, -1);
                    } else if (!isNaN(value)) {
                        vars[varName] = parseInt(value);
                    } else {
                        // Simple expression evaluation
                        if (value.includes('+')) {
                            const operands = value.split('+').map(op => op.trim());
                            let result = '';
                            let isStringConcat = false;
                            
                            operands.forEach(op => {
                                if (op.startsWith('"') && op.endsWith('"')) {
                                    result += op.slice(1, -1);
                                    isStringConcat = true;
                                } else if (vars[op] !== undefined) {
                                    if (isStringConcat || typeof vars[op] === 'string') {
                                        result += vars[op].toString();
                                        isStringConcat = true;
                                    } else {
                                        result = (result === '' ? 0 : parseInt(result)) + vars[op];
                                    }
                                } else if (op.startsWith('str(') && op.endsWith(')')) {
                                    const varName = op.substring(4, op.length - 1);
                                    if (vars[varName] !== undefined) {
                                        result += vars[varName].toString();
                                        isStringConcat = true;
                                    }
                                } else if (!isNaN(op)) {
                                    if (isStringConcat) {
                                        result += op;
                                    } else {
                                        result = (result === '' ? 0 : parseInt(result)) + parseInt(op);
                                    }
                                }
                            });
                            
                            vars[varName] = result;
                        } else if (value.includes('*')) {
                            // Multiplication
                            const operands = value.split('*').map(op => op.trim());
                            let result = 1;
                            
                            operands.forEach(op => {
                                if (vars[op] !== undefined) {
                                    result *= vars[op];
                                } else if (!isNaN(op)) {
                                    result *= parseInt(op);
                                }
                            });
                            
                            vars[varName] = result;
                        } else if (value.includes('-')) {
                            // Subtraction
                            const operands = value.split('-').map(op => op.trim());
                            let result = 0;
                            
                            operands.forEach((op, index) => {
                                if (vars[op] !== undefined) {
                                    if (index === 0) {
                                        result = vars[op];
                                    } else {
                                        result -= vars[op];
                                    }
                                } else if (!isNaN(op)) {
                                    if (index === 0) {
                                        result = parseInt(op);
                                    } else {
                                        result -= parseInt(op);
                                    }
                                }
                            });
                            
                            vars[varName] = result;
                        } else if (value.includes('^')) {
                            // Exponentiation (power)
                            const operands = value.split('^').map(op => op.trim());
                            let result = 1;
                            
                            operands.forEach((op, index) => {
                                if (vars[op] !== undefined) {
                                    if (index === 0) {
                                        result = vars[op];
                                    } else {
                                        result = Math.pow(result, vars[op]);
                                    }
                                } else if (!isNaN(op)) {
                                    if (index === 0) {
                                        result = parseInt(op);
                                    } else {
                                        result = Math.pow(result, parseInt(op));
                                    }
                                }
                            });
                            
                            vars[varName] = result;
                        } else if (value.includes(' DIV ')) {
                            // Integer division
                            const operands = value.split(' DIV ').map(op => op.trim());
                            let result = 0;
                            
                            operands.forEach((op, index) => {
                                if (vars[op] !== undefined) {
                                    if (index === 0) {
                                        result = vars[op];
                                    } else {
                                        result = Math.floor(result / vars[op]);
                                    }
                                } else if (!isNaN(op)) {
                                    if (index === 0) {
                                        result = parseInt(op);
                                    } else {
                                        result = Math.floor(result / parseInt(op));
                                    }
                                }
                            });
                            
                            vars[varName] = result;
                        } else if (value.includes('/')) {
                            // Regular division (keeping for backward compatibility)
                            const operands = value.split('/').map(op => op.trim());
                            let result = 0;
                            
                            operands.forEach((op, index) => {
                                if (vars[op] !== undefined) {
                                    if (index === 0) {
                                        result = vars[op];
                                    } else {
                                        result = Math.floor(result / vars[op]); // Integer division for GCSE
                                    }
                                } else if (!isNaN(op)) {
                                    if (index === 0) {
                                        result = parseInt(op);
                                    } else {
                                        result = Math.floor(result / parseInt(op)); // Integer division for GCSE
                                    }
                                }
                            });
                            
                            vars[varName] = result;
                        } else if (value.includes(' MOD ')) {
                            // Modulo (remainder) - GCSE standard
                            const operands = value.split(' MOD ').map(op => op.trim());
                            let result = 0;
                            
                            operands.forEach((op, index) => {
                                if (vars[op] !== undefined) {
                                    if (index === 0) {
                                        result = vars[op];
                                    } else {
                                        result = result % vars[op];
                                    }
                                } else if (!isNaN(op)) {
                                    if (index === 0) {
                                        result = parseInt(op);
                                    } else {
                                        result = result % parseInt(op);
                                    }
                                }
                            });
                            
                            vars[varName] = result;
                        } else if (vars[value] !== undefined) {
                            vars[varName] = vars[value];
                        }
                    }
                } else if (line.startsWith('print(')) {
                    // Print statement
                    const content = line.substring(6, line.length - 1);
                    if (content.startsWith('"') && content.endsWith('"')) {
                        output = content.slice(1, -1);
                    } else if (content.includes('.upper')) {
                        const varName = content.split('.')[0];
                        if (vars[varName] !== undefined) {
                            output = vars[varName].toString().toUpperCase();
                        }
                    } else if (content.includes('.lower')) {
                        const varName = content.split('.')[0];
                        if (vars[varName] !== undefined) {
                            output = vars[varName].toString().toLowerCase();
                        }
                    } else if (content.includes('[') && content.includes(']')) {
                        // Array indexing like country[x] (0-based indexing)
                        const match = content.match(/(\w+)\[(\w+)\]/);
                        if (match) {
                            const arrayVar = match[1];
                            const indexVar = match[2];
                            if (vars[arrayVar] !== undefined && vars[indexVar] !== undefined) {
                                const arrayValue = vars[arrayVar].toString();
                                const index = parseInt(vars[indexVar]); // Direct 0-based index
                                if (index >= 0 && index < arrayValue.length) {
                                    output = arrayValue[index];
                                } else {
                                    output = ''; // Index out of bounds
                                }
                            }
                        }
                    } else if (vars[content] !== undefined) {
                        output = vars[content].toString();
                    } else if (content.includes(',')) {
                        // Handle comma-separated arguments in print
                        const parts = content.split(',').map(p => p.trim());
                        let result = '';
                        parts.forEach((part, index) => {
                            if (index > 0) result += ' '; // Add space between arguments
                            if (part.startsWith('"') && part.endsWith('"')) {
                                result += part.slice(1, -1);
                            } else if (part.includes('.upper')) {
                                const varName = part.split('.')[0];
                                if (vars[varName] !== undefined) {
                                    result += vars[varName].toString().toUpperCase();
                                }
                            } else if (part.includes('.lower')) {
                                const varName = part.split('.')[0];
                                if (vars[varName] !== undefined) {
                                    result += vars[varName].toString().toLowerCase();
                                }
                            } else if (vars[part] !== undefined) {
                                result += vars[part].toString();
                            } else if (part.startsWith('str(') && part.endsWith(')')) {
                                const varName = part.substring(4, part.length - 1);
                                if (vars[varName] !== undefined) {
                                    result += vars[varName].toString();
                                }
                            }
                        });
                        output = result;
                    } else if (content.includes('+')) {
                        // String concatenation
                        const parts = content.split('+').map(p => p.trim());
                        let result = '';
                        parts.forEach(part => {
                            if (part.startsWith('"') && part.endsWith('"')) {
                                result += part.slice(1, -1);
                            } else if (vars[part] !== undefined) {
                                result += vars[part].toString();
                            } else if (part.startsWith('str(') && part.endsWith(')')) {
                                const varName = part.substring(4, part.length - 1);
                                if (vars[varName] !== undefined) {
                                    result += vars[varName].toString();
                                }
                            }
                        });
                        output = result;
                    } else if (content.includes('*')) {
                        // Arithmetic expression with multiplication
                        const operands = content.split('*').map(op => op.trim());
                        let result = 1;
                        
                        operands.forEach(op => {
                            if (vars[op] !== undefined) {
                                result *= vars[op];
                            } else if (!isNaN(op)) {
                                result *= parseInt(op);
                            }
                        });
                        
                        output = result.toString();
                    } else if (content.includes('-')) {
                        // Arithmetic expression with subtraction
                        const operands = content.split('-').map(op => op.trim());
                        let result = 0;
                        
                        operands.forEach((op, index) => {
                            if (vars[op] !== undefined) {
                                if (index === 0) {
                                    result = vars[op];
                                } else {
                                    result -= vars[op];
                                }
                            } else if (!isNaN(op)) {
                                if (index === 0) {
                                    result = parseInt(op);
                                } else {
                                    result -= parseInt(op);
                                }
                            }
                        });
                        
                        output = result.toString();
                    } else if (content.includes('/')) {
                        // Arithmetic expression with division
                        const operands = content.split('/').map(op => op.trim());
                        let result = 0;
                        
                        operands.forEach((op, index) => {
                            if (vars[op] !== undefined) {
                                if (index === 0) {
                                    result = vars[op];
                                } else {
                                    result = Math.floor(result / vars[op]);
                                }
                            } else if (!isNaN(op)) {
                                if (index === 0) {
                                    result = parseInt(op);
                                } else {
                                    result = Math.floor(result / parseInt(op));
                                }
                            }
                        });
                        
                        output = result.toString();
                    }
                    if (output) outputs.push(output);
                }
                
                return output;
            }
            
            let i = 0;
            
            function evaluateCondition(condition, vars) {
                // Simple condition evaluation for basic comparisons
                if (condition.includes('>=')) {
                    const [left, right] = condition.split('>=').map(s => s.trim());
                    let leftVal = vars[left] !== undefined ? vars[left] : left;
                    let rightVal = vars[right] !== undefined ? vars[right] : right;
                    
                    // Handle string methods like .length
                    if (left.includes('.length')) {
                        const varName = left.split('.')[0];
                        if (vars[varName] !== undefined) {
                            leftVal = vars[varName].toString().length;
                        }
                    } else {
                        // Convert to numbers if both values are numeric
                        if (!isNaN(leftVal) && !isNaN(rightVal)) {
                            leftVal = parseFloat(leftVal);
                            rightVal = parseFloat(rightVal);
                        }
                    }
                    
                    return leftVal >= rightVal;
                } else if (condition.includes('<=')) {
                    const [left, right] = condition.split('<=').map(s => s.trim());
                    let leftVal = vars[left] !== undefined ? vars[left] : left;
                    let rightVal = vars[right] !== undefined ? vars[right] : right;
                    
                    // Handle string methods like .length
                    if (left.includes('.length')) {
                        const varName = left.split('.')[0];
                        if (vars[varName] !== undefined) {
                            leftVal = vars[varName].toString().length;
                        }
                    } else {
                        // Convert to numbers if both values are numeric
                        if (!isNaN(leftVal) && !isNaN(rightVal)) {
                            leftVal = parseFloat(leftVal);
                            rightVal = parseFloat(rightVal);
                        }
                    }
                    
                    return leftVal <= rightVal;
                } else if (condition.includes('==')) {
                    const [left, right] = condition.split('==').map(s => s.trim());
                    let leftVal = vars[left] !== undefined ? vars[left] : left;
                    let rightVal = vars[right] !== undefined ? vars[right] : right;
                    
                    // Handle string literals
                    if (leftVal.startsWith && leftVal.startsWith('"') && leftVal.endsWith('"')) {
                        leftVal = leftVal.slice(1, -1);
                    }
                    if (rightVal.startsWith && rightVal.startsWith('"') && rightVal.endsWith('"')) {
                        rightVal = rightVal.slice(1, -1);
                    }
                    
                    return leftVal == rightVal;
                } else if (condition.includes('!=')) {
                    const [left, right] = condition.split('!=').map(s => s.trim());
                    let leftVal = vars[left] !== undefined ? vars[left] : left;
                    let rightVal = vars[right] !== undefined ? vars[right] : right;
                    
                    // Handle string literals
                    if (leftVal.startsWith && leftVal.startsWith('"') && leftVal.endsWith('"')) {
                        leftVal = leftVal.slice(1, -1);
                    }
                    if (rightVal.startsWith && rightVal.startsWith('"') && rightVal.endsWith('"')) {
                        rightVal = rightVal.slice(1, -1);
                    }
                    
                    return leftVal != rightVal;
                } else if (condition.includes('>')) {
                    const [left, right] = condition.split('>').map(s => s.trim());
                    let leftVal = vars[left] !== undefined ? vars[left] : left;
                    let rightVal = vars[right] !== undefined ? vars[right] : right;
                    
                    // Handle string methods like .length
                    if (left.includes('.length')) {
                        const varName = left.split('.')[0];
                        if (vars[varName] !== undefined) {
                            leftVal = vars[varName].toString().length;
                        }
                    } else {
                        // Convert to numbers if both values are numeric
                        if (!isNaN(leftVal) && !isNaN(rightVal)) {
                            leftVal = parseFloat(leftVal);
                            rightVal = parseFloat(rightVal);
                        }
                    }
                    
                    return leftVal > rightVal;
                } else if (condition.includes('<')) {
                    const [left, right] = condition.split('<').map(s => s.trim());
                    let leftVal = vars[left] !== undefined ? vars[left] : left;
                    let rightVal = vars[right] !== undefined ? vars[right] : right;
                    
                    // Handle string methods like .length
                    if (left.includes('.length')) {
                        const varName = left.split('.')[0];
                        if (vars[varName] !== undefined) {
                            leftVal = vars[varName].toString().length;
                        }
                    } else {
                        // Convert to numbers if both values are numeric
                        if (!isNaN(leftVal) && !isNaN(rightVal)) {
                            leftVal = parseFloat(leftVal);
                            rightVal = parseFloat(rightVal);
                        }
                    }
                    
                    return leftVal < rightVal;
                }
                return false;
            }
            
            while (i < lines.length) {
                const line = lines[i];
                const lineNum = i + 1;
                
                if (line.startsWith('if ') && line.includes(' then')) {
                    // If-elseif-else statement
                    const condition = line.substring(3, line.indexOf(' then')).trim();
                    
                    // Find the structure of the if statement
                    let endifIndex = -1;
                    let elseifIndices = [];
                    let elseIndex = -1;
                    let depth = 0;
                    
                    for (let j = i + 1; j < lines.length; j++) {
                        if (lines[j].startsWith('if ')) depth++;
                        if (lines[j] === 'endif') {
                            if (depth === 0) {
                                endifIndex = j;
                                break;
                            }
                            depth--;
                        } else if (lines[j].startsWith('elseif ') && depth === 0) {
                            elseifIndices.push(j);
                        } else if (lines[j] === 'else' && depth === 0) {
                            elseIndex = j;
                        }
                    }
                    
                    // Evaluate conditions and execute the appropriate block
                    let conditionMet = evaluateCondition(condition, variables);
                    let executionStart = i + 1;
                    let executionEnd = elseifIndices.length > 0 ? elseifIndices[0] : 
                                      (elseIndex !== -1 ? elseIndex : endifIndex);
                    
                    if (!conditionMet) {
                        // Check elseif conditions
                        for (let k = 0; k < elseifIndices.length; k++) {
                            const elseifLine = lines[elseifIndices[k]];
                            const elseifCondition = elseifLine.substring(7, elseifLine.indexOf(' then')).trim();
                            
                            if (evaluateCondition(elseifCondition, variables)) {
                                conditionMet = true;
                                executionStart = elseifIndices[k] + 1;
                                executionEnd = k + 1 < elseifIndices.length ? elseifIndices[k + 1] : 
                                              (elseIndex !== -1 ? elseIndex : endifIndex);
                                break;
                            }
                        }
                        
                        // If no conditions met and there's an else
                        if (!conditionMet && elseIndex !== -1) {
                            executionStart = elseIndex + 1;
                            executionEnd = endifIndex;
                            conditionMet = true;
                        }
                    }
                    
                    // Execute the appropriate block (only trace lines that actually execute)
                    if (conditionMet) {
                        for (let bodyLine = executionStart; bodyLine < executionEnd; bodyLine++) {
                            const bodyLineCode = lines[bodyLine];
                            const bodyLineNum = bodyLine + 1;
                            const output = executeStatement(bodyLineCode, bodyLineNum, variables);
                            addTraceEntry(bodyLineNum, variables, output);
                        }
                    }
                    
                    // Skip to after endif
                    i = endifIndex + 1;
                    continue;
                } else if (line.startsWith('while ')) {
                    // While loop
                    const condition = line.substring(6).trim();
                    
                    // Find the matching endwhile statement
                    let endwhileIndex = -1;
                    let depth = 0;
                    for (let j = i + 1; j < lines.length; j++) {
                        if (lines[j].startsWith('while ')) depth++;
                        if (lines[j] === 'endwhile') {
                            if (depth === 0) {
                                endwhileIndex = j;
                                break;
                            }
                            depth--;
                        }
                    }
                    
                    // Execute the while loop (only trace executing statements, not condition evaluations)
                    while (evaluateCondition(condition, variables)) {
                        // Execute loop body
                        for (let bodyLine = i + 1; bodyLine < endwhileIndex; bodyLine++) {
                            const bodyLineCode = lines[bodyLine];
                            const bodyLineNum = bodyLine + 1;
                            const output = executeStatement(bodyLineCode, bodyLineNum, variables);
                            addTraceEntry(bodyLineNum, variables, output);
                        }
                    }
                    
                    // Skip to after endwhile
                    i = endwhileIndex + 1;
                    continue;
                } else if (line === 'do') {
                    // Do-until loop
                    // Find the matching until statement
                    let untilIndex = -1;
                    let depth = 0;
                    for (let j = i + 1; j < lines.length; j++) {
                        if (lines[j] === 'do') depth++;
                        if (lines[j].startsWith('until ')) {
                            if (depth === 0) {
                                untilIndex = j;
                                break;
                            }
                            depth--;
                        }
                    }
                    
                    // Execute the do-until loop (execute body at least once, then check condition)
                    do {
                        // Execute loop body
                        for (let bodyLine = i + 1; bodyLine < untilIndex; bodyLine++) {
                            const bodyLineCode = lines[bodyLine];
                            const bodyLineNum = bodyLine + 1;
                            const output = executeStatement(bodyLineCode, bodyLineNum, variables);
                            addTraceEntry(bodyLineNum, variables, output);
                        }
                        
                        // Get the until condition
                        const untilLine = lines[untilIndex];
                        const condition = untilLine.substring(6).trim(); // Remove "until "
                        
                        // Check if condition is met to exit the loop
                        if (evaluateCondition(condition, variables)) {
                            break;
                        }
                    } while (true);
                    
                    // Skip to after until
                    i = untilIndex + 1;
                    continue;
                } else if (line.startsWith('for ') && line.includes(' to ')) {
                    // For loop
                    const forMatch = line.match(/for\s+(\w+)\s*=\s*(\d+)\s+to\s+(\d+)/);
                    if (forMatch) {
                        const loopVar = forMatch[1];
                        const startVal = parseInt(forMatch[2]);
                        const endVal = parseInt(forMatch[3]);
                        
                        // Find the matching next statement
                        let nextLineIndex = -1;
                        let depth = 0;
                        for (let j = i + 1; j < lines.length; j++) {
                            if (lines[j].startsWith('for ')) depth++;
                            if (lines[j].startsWith('next ')) {
                                if (depth === 0) {
                                    nextLineIndex = j;
                                    break;
                                }
                                depth--;
                            }
                        }
                        
                        // Execute the loop
                        for (let loopVal = startVal; loopVal <= endVal; loopVal++) {
                            // Set the loop variable and trace the for line
                            variables[loopVar] = loopVal;
                            addTraceEntry(lineNum, variables, '');
                            
                            // Execute loop body
                            for (let bodyLine = i + 1; bodyLine < nextLineIndex; bodyLine++) {
                                const bodyLineCode = lines[bodyLine];
                                const bodyLineNum = bodyLine + 1;
                                const output = executeStatement(bodyLineCode, bodyLineNum, variables);
                                addTraceEntry(bodyLineNum, variables, output);
                            }
                        }
                        
                        // Skip to after the next statement
                        i = nextLineIndex + 1;
                        continue;
                    }
                } else if (line.startsWith('next ') || line === 'endif' || line === 'else' || line.startsWith('elseif ') || line === 'endwhile' || line.startsWith('until ')) {
                    // Skip control flow statements as they're handled by their parent structures
                    i++;
                    continue;
                } else {
                    // Regular statement
                    const output = executeStatement(line, lineNum, variables);
                    addTraceEntry(lineNum, variables, output);
                }
                
                i++;
            }
            
            expectedTrace = trace;
            programVariables = Object.keys(variables);
        }

        function createTraceTable() {
            const table = document.getElementById('traceTable');
            const thead = table.querySelector('thead tr');
            const tbody = table.querySelector('tbody');
            
            // Clear existing content
            thead.innerHTML = '<th>Line Number</th>';
            tbody.innerHTML = '';
            
            // Add variable columns
            programVariables.forEach(varName => {
                const th = document.createElement('th');
                th.textContent = varName;
                thead.appendChild(th);
            });
            
            // Add output column
            const outputTh = document.createElement('th');
            outputTh.textContent = 'Output';
            thead.appendChild(outputTh);
            
            // Create rows (enough for the expected trace + a few extra)
            for (let i = 0; i < expectedTrace.length + 2; i++) {
                const row = document.createElement('tr');
                
                // Line number (student enters this)
                const lineCell = document.createElement('td');
                const lineInput = document.createElement('input');
                lineInput.type = 'text';
                lineInput.placeholder = '';
                lineCell.appendChild(lineInput);
                row.appendChild(lineCell);
                
                // Variable cells
                programVariables.forEach(varName => {
                    const cell = document.createElement('td');
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.placeholder = '';
                    cell.appendChild(input);
                    row.appendChild(cell);
                });
                
                // Output cell
                const outputCell = document.createElement('td');
                const outputInput = document.createElement('input');
                outputInput.type = 'text';
                outputInput.placeholder = '';
                outputCell.appendChild(outputInput);
                row.appendChild(outputCell);
                
                tbody.appendChild(row);
            }
        }

        function markAnswer() {
            if (!currentProgram || expectedTrace.length === 0) {
                alert('Please generate a program first!');
                return;
            }
            
            const tbody = document.getElementById('traceTable').querySelector('tbody');
            const rows = tbody.querySelectorAll('tr');
            
            let correct = 0;
            let total = 0;
            let feedback = [];
            
            // Create a list of user entries in order
            const userEntries = [];
            rows.forEach(row => {
                const cells = row.querySelectorAll('td');
                const lineInput = cells[0].querySelector('input');
                const userLineNumber = lineInput.value.trim();
                
                if (userLineNumber) {
                    const lineNum = parseInt(userLineNumber);
                    const userEntry = {
                        lineNumber: lineNum,
                        lineInput: lineInput,
                        variables: {},
                        outputInput: cells[cells.length - 1].querySelector('input')
                    };
                    
                    // Store variable inputs
                    programVariables.forEach((varName, varIndex) => {
                        userEntry.variables[varName] = cells[varIndex + 1].querySelector('input');
                    });
                    
                    userEntries.push(userEntry);
                }
            });
            
            // Track variable values throughout execution
            const variableHistory = {};
            programVariables.forEach(varName => {
                variableHistory[varName] = undefined;
            });
            
            // Process expected trace in order, matching with user entries
            let userIndex = 0;
            let currentIteration = 1;
            let lastLoopVar = null;
            
            expectedTrace.forEach((expectedEntry, traceIndex) => {
                const lineNum = expectedEntry.lineNumber;
                
                // Check if we're in a new iteration (loop variable changed)
                const loopVarName = Object.keys(expectedEntry.variables).find(varName => 
                    varName === 'x' || varName === 'i' || varName.length === 1
                );
                if (loopVarName && expectedEntry.variables[loopVarName] !== lastLoopVar) {
                    if (lastLoopVar !== null) {
                        currentIteration++;
                    }
                    lastLoopVar = expectedEntry.variables[loopVarName];
                }
                
                // Find the next user entry that matches this line number
                let userEntry = null;
                if (userIndex < userEntries.length && userEntries[userIndex].lineNumber === lineNum) {
                    userEntry = userEntries[userIndex];
                    userIndex++;
                }
                
                if (userEntry) {
                    // Check line number
                    total++;
                    correct++;
                    userEntry.lineInput.style.backgroundColor = '#c6f6d5';
                    
                    // Check variables
                    programVariables.forEach(varName => {
                        const input = userEntry.variables[varName];
                        const userValue = input.value.trim();
                        const expectedValue = expectedEntry.variables[varName];
                        const previousValue = variableHistory[varName];
                        
                        total++;
                        
                        // Check if the value changed from the previous state
                        const valueChanged = expectedValue !== previousValue;
                        
                        if (valueChanged) {
                            // Value changed, should be filled in
                            if (expectedValue === undefined) {
                                if (userValue === '' || userValue === 'undefined') {
                                    correct++;
                                    input.style.backgroundColor = '#c6f6d5';
                                } else {
                                    input.style.backgroundColor = '#fed7d7';
                                    feedback.push(`Line ${lineNum}, ${varName}: Expected undefined (changed), got "${userValue}"`);
                                }
                            } else {
                                if (userValue == expectedValue.toString()) {
                                    correct++;
                                    input.style.backgroundColor = '#c6f6d5';
                                } else {
                                    input.style.backgroundColor = '#fed7d7';
                                    feedback.push(`Line ${lineNum}, ${varName}: Expected "${expectedValue}" (changed), got "${userValue}"`);
                                }
                            }
                        } else {
                            // Value didn't change, should be empty
                            if (userValue === '') {
                                correct++;
                                input.style.backgroundColor = '#c6f6d5';
                            } else {
                                input.style.backgroundColor = '#fed7d7';
                                feedback.push(`Line ${lineNum}, ${varName}: Value unchanged, should be empty but got "${userValue}"`);
                            }
                        }
                        
                        // Update the variable history
                        variableHistory[varName] = expectedValue;
                    });
                    
                    // Check output
                    const userOutput = userEntry.outputInput.value.trim();
                    const expectedOutput = expectedEntry.output || '';
                    
                    total++;
                    
                    if (userOutput === expectedOutput) {
                        correct++;
                        userEntry.outputInput.style.backgroundColor = '#c6f6d5';
                    } else {
                        userEntry.outputInput.style.backgroundColor = '#fed7d7';
                        if (expectedOutput) {
                            feedback.push(`Line ${lineNum}, Output: Expected "${expectedOutput}", got "${userOutput}"`);
                        } else if (userOutput) {
                            feedback.push(`Line ${lineNum}, Output: Expected no output, got "${userOutput}"`);
                        }
                    }
                } else {
                    // Missing entry
                    feedback.push(`Missing entry for line ${lineNum} (iteration ${currentIteration})`);
                    total += 1 + programVariables.length + 1; // Line number + variables + output
                    // Update variable history even for missing entries
                    programVariables.forEach(varName => {
                        variableHistory[varName] = expectedEntry.variables[varName];
                    });
                }
            });
            
            // Check for extra entries (remaining user entries that weren't matched)
            for (let i = userIndex; i < userEntries.length; i++) {
                const userEntry = userEntries[i];
                total++;
                userEntry.lineInput.style.backgroundColor = '#fed7d7';
                feedback.push(`Line ${userEntry.lineNumber}: Extra entry not expected in the trace`);
                
                // Mark variable cells as incorrect too
                programVariables.forEach(varName => {
                    const input = userEntry.variables[varName];
                    if (input.value.trim()) {
                        total++;
                        input.style.backgroundColor = '#fed7d7';
                    }
                });
                
                // Mark output cell as incorrect if filled
                if (userEntry.outputInput.value.trim()) {
                    total++;
                    userEntry.outputInput.style.backgroundColor = '#fed7d7';
                }
            }
            
            // Display results
            const feedbackDiv = document.getElementById('feedback');
            const scoreDiv = document.getElementById('score');
            const feedbackText = document.getElementById('feedbackText');
            
            const percentage = total > 0 ? Math.round((correct / total) * 100) : 0;
            
            scoreDiv.textContent = `Score: ${correct}/${total} (${percentage}%)`;
            
            if (percentage >= 80) {
                feedbackDiv.className = 'feedback success';
                // Clear any inline styles that might override the CSS class
                feedbackDiv.style.backgroundColor = '';
                feedbackDiv.style.color = '';
                feedbackDiv.style.borderColor = '';
                feedbackText.textContent = 'Excellent work! ' + (feedback.length > 0 ? 'Minor corrections needed:' : 'Perfect!');
            } else if (percentage >= 60) {
                feedbackDiv.className = 'feedback';
                feedbackDiv.style.backgroundColor = '#fef5e7';
                feedbackDiv.style.color = '#d69e2e';
                feedbackDiv.style.borderColor = '#f6e05e';
                feedbackText.textContent = 'Good effort! Some corrections needed:';
            } else {
                feedbackDiv.className = 'feedback error';
                // Clear any inline styles that might override the CSS class
                feedbackDiv.style.backgroundColor = '';
                feedbackDiv.style.color = '';
                feedbackDiv.style.borderColor = '';
                feedbackText.textContent = 'Keep practicing! Corrections needed:';
            }
            
            if (feedback.length > 0) {
                feedbackText.innerHTML += '<br><br>' + feedback.join('<br>');
            }
            
            feedbackDiv.style.display = 'block';
        }

        function clearTable() {
            const tbody = document.getElementById('traceTable').querySelector('tbody');
            const rows = tbody.querySelectorAll('tr');
            
            // Clear all input values and reset background colors
            rows.forEach(row => {
                const inputs = row.querySelectorAll('input');
                inputs.forEach(input => {
                    input.value = '';
                    input.style.backgroundColor = '';
                });
            });
            
            // Hide feedback
            document.getElementById('feedback').style.display = 'none';
        }

        function toggleProgramSelector() {
            const mode = document.getElementById('mode').value;
            const programSelector = document.getElementById('programSelector');
            const generateButton = document.querySelector('.btn-primary');
            
            if (mode === 'select') {
                programSelector.style.display = 'flex';
                generateButton.textContent = 'üìã Load Selected Program';
                updateProgramSelector();
            } else {
                programSelector.style.display = 'none';
                generateButton.textContent = 'üîÑ Generate New Program';
            }
        }

        function updateProgramSelector() {
            const difficulty = document.getElementById('difficulty').value;
            const programChoice = document.getElementById('programChoice');
            const programList = programs[difficulty];
            
            // Clear existing options
            programChoice.innerHTML = '';
            
            // Add programs for the selected difficulty
            programList.forEach((program, index) => {
                const option = document.createElement('option');
                option.value = index;
                option.textContent = program.description;
                programChoice.appendChild(option);
            });
        }

        // Initialize with a program
        updateProgramSelector(); // Initialize the program selector with easy programs
        generateProgram();
    </script>
</body>
</html>